InterpreterTest
---
SimpleAssign
---
x = 1
---
x
---
---
SimpleAddition
---
x = 1
y = x + 1
---
y
---
---
BuiltinTypeAssign
---
x = str
y = int
z = bool
---
x y z
---
---
StringLiteral
---
x = ""
y = "abcd"
z = 'abcd\n'
---
x y z
---
---
StringLen
---
x = "".__len__()
y = "abcd".__len__()
z = 'abcd\n'.__len__()
---
x y z
---
---
StringLenNone
---
x = "".__lenx__()
---
---
1 4 StrictModuleUnhandledException(AttributeError)
---
StringStrip
---
x = "abc  ".strip()
y = "abcccc".strip("c")
---
x y
---
---
StringSplit
---
x = "abc  ".split()
y = "abcccc".split("c")
z = "abcccc".split(sep="c")
---
x y z
---
---
ListLiteral
---
x = []
y = [1, 2, 3]
z = [[1]]
---
x y z
---
---
ListLen
---
x = [].__len__()
y = [1, 2, 3].__len__()
z = [[1], 3].__len__()
---
x y z
---
---
ListAppend
---
x = []
x.append([])
x.append(23)
x.extend([3, 4])
---
x
---
---
ListInit
---
x = []
y = []
x.__init__([1, 2, 3])
y.__init__([1, 2, 3].__iter__())
---
x y
---
---
TupleLiteral
---
x = ()
y = (1, 2, 3)
z = (1,)
w = tuple.__new__(tuple, (2, 3, 4))
v = tuple.__new__(tuple)
---
x y z w v
---
---
TupleIndex
---
t = (1, 2)
x = t.index(1)
---
x
---
---
DictLiteral
---
t = {1: 2}
t1 = {1: 2, 3: 4}
t2 = {**t}
t3 = {6: 7, **t, **t1}
---
t t1 t2 t3
---
---
PrimitiveCompare
---
x = (1).__eq__(1)
y = (1).__eq__(2)
---
x y
---
---
FunctionSimple
---
def f():
    return 1

def g():
    return

def h(x, /, y, z=1, *args, w, v=4, **kwargs):
    return x + y + z + w + v

def i(x, /, y, z=1, *args, w, v=4, **kwargs):
    r = 0
    for i in  args:
        r += i
    for i in kwargs.values():
        r += i
    return x + y + z + w + v + r

x = f()
g()
y = h(1, 2, 3, w=4)
z = h(1, y=2, w=4)
w = h(1, w = 4, y = 2, z = 3)
v = h(1, 2, 3, 4, 5, w=6, a=7, b=8)
u = i(1, 2, 3, 4, 5, w=6, a=7, b=8)
---
x y z w v u
---
---
FunctionPosOnly
---
def f(x = 1, /,  y =1):
    return x + y
x = f()
y = f(2)
z = f(2, 3)
w = f(2, y = 4)
v = f(y = 5)
---
x y z w v
---
---
ClassSimple
---
class C:
    pass
---
---
---
StubImplicit
---
from implicit_test import f

y = f()
---
y
---
---
StubFullImplicit
---
from full_implicit_test import f

y = f()
---
y
---
---
InitNoStub
---
from no_stub import g

y = g(2)
---
y
---
---
PackageNoStub
---
import no_stub.abc as abc

x = abc.x
---
x
---
---
test_float
---
x = 1.0
y = x.is_integer()
---
x y
---
---
test_int_divide
---
x = 1 / 2
---
x
---
---
test_int_float
---
x = 1 + 1.0
---
x
---
---
test_float_int
---
x = 1.0 + 1.0
---
x
---
---
test_complex_float @disabled
---
x = 1j + 1.0
---
x
---
---
test_float_complex @disabled
---
x = 1.0 + 1j
---
x
---
---
test_int_complex @disabled
---
x = 1 + 1j
---
x
---
---
test_int_new
---
a = int(42)
b = int('42')
c = int()
---
a b c
---
---
test_int_new_unsupported
---
a = int([])
---
---
1 4 UnsupportedException int list
---
test_int_new_bad_cls
---
int.__new__(object)
---
---
1 0 StrictModuleUnhandledException(TypeError)
---
test_int_new_bad_str
---
a = int('abc')
---
---
1 4 StrictModuleUnhandledException(ValueError)
---
test_complex_int @disabled
---
x = 1j + 1.0
---
x
---
---
test_mro
---
class C:
    pass
x = C.mro() == [C, object]
---
x
---
---
test_mro_explicit_obj
---
class C(object):
    pass
x = C.mro() == [C, object]
---
x
---
---
test_mro_inheritance
---
class C:
    pass

class D(C):
    pass
x = D.mro() == [D, C, object]
---
x
---
---
test_mro_multiple_inheritance
---
class C:
    pass

class D:
    pass

class E(C, D):
    pass
x = E.mro() == [E, C, D, object]
---
x
---
---
test_mro_conflict
---

class A:
    pass


class B:
    pass


class C(B, A):
    pass


class D(A, B):
    pass


class E(C, D):
    pass
---
---
18 0 StrictModuleUnhandledException(TypeError)
---
test_metaclass_attr_resolution
---
class MC(type):
    x = 42


class C(metaclass=MC):
    x = 'abc'

x_inst = C().x
x_cls = C.x
---
x_inst x_cls
---
---
test_metaclass_attr_property
---
class MC(type):
    @property
    def x(self):
        return 42


class C(metaclass=MC):
    x = 'abc'

x_inst = C().x
x_cls = C.x
---
x_inst x_cls
---
---
test_metaclass_extra_kwargs
---

class MC(type):
    def __new__(cls, name, bases, dct, extra=0):
        ret = super().__new__(cls, name, bases, dct)
        ret.extra = extra
        return ret

class C(metaclass=MC):
    pass

class D(metaclass=MC, extra=1):
    pass

x = C.extra
y = D.extra
---
x y
---
---
test_metaclass_prepare
---
class MC(type):
    @classmethod
    def __prepare__(self, name, bases):
        res = {'abc': 42}
        return res

class C(metaclass=MC):
    pass

x = C().abc
---
x
---
---
test_metaclass_prepare_dict_subclass
---
class mydict(dict):
    def __setitem__(self, index, value):
        super().__setitem__(index.upper(), value)

class MC(type):
    @classmethod
    def __prepare__(self, name, bases):
        res = mydict()
        return res

class C(metaclass=MC):
    abc = 42

x = C().ABC
---
x
---
---
test_metaclass_override_call
---
class MC(type):
    def __call__(self, *args):
        return args

class C(metaclass=MC):
    pass

x = C(42)
y = C('abc')
---
x y
---
---
test_init_subclass
---
class Base:
    def __init_subclass__(cls, extra=0):
        cls.extra = extra

class C(Base):
    def __init_subclass__(cls, extra=0):
        super().__init_subclass__(extra + 1)

class D(Base, extra=1):
    pass

class E(C, extra=1):
    pass

x = C.extra
y = D.extra
z = E.extra
---
x y z
---
---
test_cell_meth_with_instance
---
x = bytes.upper(b'abc')
---
x
---
---
test_cell_meth_missing_instance
---
bytes.upper()
---
---
1 0 StrictModuleUnhandledException(TypeError)
---
test_cell_meth_bad_self
---
bytes.upper(42)
---
---
1 0 StrictModuleUnhandledException(TypeError)
---
test_property_reinit
---
class C:
    @property
    def f(self):
        return 42

def g(self):
    return "abc"

C.f.__init__(g)
x = C().f
---
x
---
---
test_property_no_setting
---
class C:
    @property
    def f(self):
        return 42

C().f = 42
---
---
6 0 StrictModuleUnhandledException(AttributeError)
---
test_property_no_deleting
---
class C:
    @property
    def f(self):
        return 42

del C().f
---
---
6 0 StrictModuleUnhandledException(AttributeError)
---
test_property_no_getting
---
class C:
    f = property(None, lambda x, y: None)

x = C().f
---
---
4 4 StrictModuleUnhandledException(AttributeError)
---
test_property_init_fset
---
class C:
    def x(self, value):
        self.v = 'abc'
    f = property(None, x, None)

a = C()
a.f = 42
x = a.v
---
x
---
---
test_property_init_fdel
---
class C:
    def x(self):
        self.v = 'abc'
    f = property(None, None, x)

a = C()
del a.f
x =  a.v
---
x
---
---
test_classmethod_get
---
class C:
    val = 42
    @classmethod
    def f(cls):
        return cls.val
class D(C):
    val = 43

t0 = C.f()
t1 = D.f()
t2 = C().f()
t3 = D().f()
t4 = C.__dict__['f'].__get__(C, C)()
t5 = C.__dict__['f'].__get__(D, D)()
t6 = C.__dict__['f'].__get__(C, C())()
t7 = C.__dict__['f'].__get__(D, D())()
---
t0 t1 t2 t3 t4 t5 t6 t7
---
---
test_subclass_type
---
class C(type):
    pass

x = C('foo', (), {})
---
---
---
test_subclass_object
---
class C(object):
    pass

x = C()
---
---
---
test_subclass_int
---
class C(int):
    pass

x = C()
y = x + 1
---
y
---
---
test_namedtuple_def
---
from collections import namedtuple
P = namedtuple("P", "x, y")
x = P._fields[0]
y = P._fields[1]
---
x y
---
---
test_namedtuple_def_keyword_args
---
from collections import namedtuple
P = namedtuple(typename="P", field_names="x, y")
x = P._fields[0]
y = P._fields[1]
---
x y
---
---
test_namedtuple_access
---
from collections import namedtuple
P = namedtuple("P", "x, y")
p = P(1, '2')
a = p.x
b = p[1]
---
a b
---
---
test_namedtuple_access_2
---
from collections import namedtuple
P = namedtuple("P", ["x", "y"])
p = P(1, '2')
a = p.x
b = p[1]
---
a b
---
---
test_namedtuple_replace
---
from collections import namedtuple
P = namedtuple("P", "x, y")
p = P(1, '2')
p1 = p._replace(y=2)
a = p1.x
b = p1.y
---
a b
---
---
test_namedtuple_error_underscored_name
---
from collections import namedtuple
P = namedtuple("P", "x, _y")
---
---
2 4 StrictModuleUnhandledException(ValueError) 80 12 StrictModuleUserException ValueError
---
test_namedtuple_error_keyword_name
---
from collections import namedtuple
P = namedtuple("P", "x, def")
---
---
2 4 StrictModuleUnhandledException(ValueError) 74 12 StrictModuleUserException ValueError
---
test_namedtuple_error_non_identifier_name
---
from collections import namedtuple
P = namedtuple("P", "x, ?")
---
---
2 4 StrictModuleUnhandledException(ValueError) 71 12 StrictModuleUserException ValueError
---
test_namedtuple_duplicate_name
---
from collections import namedtuple
P = namedtuple("P", "x x")
---
---
2 4 StrictModuleUnhandledException(ValueError) 83 12 StrictModuleUserException ValueError
---
test_namedtuple_fields
---
from collections import namedtuple
P = namedtuple("P", "x y")
p = P(1, 2)
d = p._fields
f = d[0]
---
f
---
---
test_namedtuple_kwargs
---
from collections import namedtuple
P = namedtuple("P", "x y")
p = P(x = 1, y = 2)
x = p.x
y = p.y
---
x y
---
---
test_namedtuple_kwargs_subclass
---
from collections import namedtuple
P = namedtuple("P", "x y")
class Q(P):
    pass
q = Q(x = 1, y = 2)
x = q.x
y = q.y
---
x y
---
---
test_classmethod
---
class C:
    @classmethod
    def f(cls):
        return 42

x = C.f
y = C.f()
z = C().f()
a = y == z
b = y == 42
---
a b
---
---
test_classmethod_no_args
---
classmethod()
---
---
1 0 StrictModuleUnhandledException(TypeError)
---
test_classmethod_too_many_args
---
classmethod(1, 2)
---
---
1 0 StrictModuleUnhandledException(TypeError)
---
test_classmethod_kw_args
---
classmethod(x=2)
---
---
1 0 StrictModuleUnhandledException(TypeError)
---
test_staticmethod
---
class C:
    @staticmethod
    def f(x):
        return x

x = C.f
y = C.f(42)
z = C().f(42)
a = z == y
b = y == 42
---
a b
---
---
test_staticmethod_no_args
---
staticmethod()
---
---
1 0 StrictModuleUnhandledException(TypeError)
---
test_staticmethod_too_many_args
---
staticmethod(1, 2)
---
---
1 0 StrictModuleUnhandledException(TypeError)
---
test_staticmethod_kw_args
---
staticmethod(x=2)
---
---
1 0 StrictModuleUnhandledException(TypeError)
---
test_int_object_subtype
---
class C(int, object):
    pass


x = C(1)
y = x + 1
---
y
---
---
test_int_bool_add
---
x = True + 3
y = 3 + False
z = 4 - True
---
x y z
---
---
test_object_int_add_unsupported
---
x = object() + 3
---
---
1 4 StrictModuleUnhandledException(TypeError)
---
test_int_subtype
---
class C(int):
    pass

x = C(4) % 4
y = 4 % C(4)
---
x y
---
---
test_int_subtype_pow
---
class C(int):
    pass

x = C(4).__pow__(4, None)
y = (4).__pow__(C(4), None)
---
x y
---
---
test_int_subtype_pow_bad_mod
---
class C(int):
    pass

x = C(1).__pow__(2, 'abc')
---
---
4 4 StrictModuleUnhandledException(TypeError)
---
test_int_subtype_unary
---
class C(int):
    pass

x = ~C(4)
---
x
---
---
test_int_subtype_overrides
---
class C(int):
    def __add__(self, other):
        return "hello"

    def __radd__(self, other):
        return "goodbye"

    def f(self):
        return "f"

x = C(42) + 42
y = 42 + C(42)
z = C(42) + C(42)
---
x y z
---
---
test_int_duner_methods
---
x = int.__rxor__(4, 4)
---
x
---
---
test_int_unary_duner_methods
---
x = int.__neg__(4)
---
x
---
---
test_float_object_subtype_add
---
class C(float):
    pass


x = C(1) + 2.0
---
x
---
---
test_float_object_subtype_reverse_add
---
class C(float):
    pass


x = 1.0 + C(2)
---
x
---
---
test_complex_object_subtype_add_disallowed @disabled
---
class C(complex):
    pass


x = C(1) + 2j
---
---
StrictModuleNotSupportedException
---
test_complex_object_subtype_reverse_add_disallowed @disabled
---
class C(complex):
    pass


x = 1j + C(2)
---
---
StrictModuleNotSupportedException
---
test_float_invert
---
x = ~42.0
---
---
1 4 StrictModuleUnhandledException(TypeError)
---
test_complex_abs @disabled
---
x = abs(42j)
---
x
---
---
test_complex_invert @disabled
---
x = ~42j
---
---
StrictModuleTypeError
---
test_zero_div_int
---
x = 1/0
---
---
1 4 StrictModuleUnhandledException(ZeroDivisionError)
---
test_zero_div_float
---
x = 1.0/0.0
---
---
1 4 StrictModuleUnhandledException(ZeroDivisionError)
---
test_zero_div_complex @disabled
---
x = 0j/0j
---
---
StrictModuleZeroDivisionError
---
test_numeric_bin_ops
---
x = -1.1 != -1.1
---
x
---
---
test_numeric_builtin_ops
---
x = abs(-1.1)
---
x
---
---
test_numeric_divmod
---
x = divmod(-1.1, -1.1)
y = divmod(20, 2.1)
---
x y
---
---
test_divmod
---
class A:
    def __divmod__(self, other):
        return 1

    def __rdivmod__(self, other):
        return 2

class B:
    def __divmod__(self, other):
        return 3

    def __rdivmod__(self, other):
        return 4

class C(A):
    def __divmod__(self, other):
        return 5

    def __rdivmod__(self, other):
        return 6

x1 = divmod(A(), A())
x2 = divmod(A(), B())
x3 = divmod(A(), C())
x4 = divmod(B(), A())
x5 = divmod(B(), B())
x6 = divmod(B(), C())
x7 = divmod(C(), A())
x8 = divmod(C(), B())
x9 = divmod(C(), C())
---
x1 x2 x3 x4 x5 x6 x7 x8 x9
---
---
test_method
---
class C:
    def f(self):
        return 42


x = C().f()
---
x
---
---
test_method_from_class
---
class C:
    def f(self):
        return self


x = C.f
y = C.f(42)
---
y
---
---
test_dataclass_def
---
from dataclasses import dataclass
@dataclass
class C:
    a: int
---
---
---
test_dataclass_instantiation
---
from dataclasses import dataclass
@dataclass
class C:
    a: int
c = C(1)
a = c.a
---
a
---
---
test_dataclass_default
---
from dataclasses import dataclass
@dataclass
class C:
    a: int = 1
c = C()
c1 = C(2)
a = c.a
a1 = c1.a
---
a a1
---
---
test_dataclass_default_fixed
---
from dataclasses import dataclass
@dataclass
class C:
    a: int = 1
c = C()
C.a = 2
c1 = C()
a = c.a
a1 = c1.a
---
a a1
---
---
test_dataclass_default_inheritance
---
from dataclasses import dataclass
@dataclass
class C:
    a: int = 1

@dataclass
class D(C):
    b: int = 2
d = D(b = 3)
d1 = D()
a = d.a
b = d.b
a1 = d1.a
b1 = d1.b
---
a a1 b b1
---
---
test_dataclass_post_init
---
from dataclasses import dataclass
@dataclass
class C:
    a: int
    def __post_init__(self):
        self.b = self.a + 1
        self.d = self.a
c = C(1)
b = c.b
d = c.d
---
b d
---
---
test_dataclass_init_conflict
---
from dataclasses import dataclass
@dataclass(frozen=True)
class C:
    a: int
    b: int
c = C(1, a=1)
---
---
6 4 StrictModuleUnhandledException(TypeError)
---
test_dataclass_field_default
---
from dataclasses import field, dataclass
@dataclass
class C:
    a: int = field(default=1)

c = C()
a = c.a
c1 = C(2)
a1 = c1.a
---
a a1
---
---
test_dataclass_field_default_factory
---
from dataclasses import field, dataclass
def fact():
    return 1
@dataclass
class C:
    a: int = field(default_factory=fact)

c = C()
a = c.a
c1 = C(2)
a1 = c1.a
---
a a1
---
---
test_dataclass_default_and_factory
---
from dataclasses import field, dataclass
def fact():
    return 1
@dataclass
class C:
    a: int = field(default_factory=fact, default=1)
---
---
6 13 StrictModuleUnhandledException(ValueError) 365 8 StrictModuleUserException ValueError
---
test_dataclass_default_order
---
from dataclasses import field, dataclass
def fact():
    return 1
@dataclass
class C:
    a: int = field(default=1)
    b: int
---
---
4 1 StrictModuleUnhandledException(TypeError) 1185 11 StrictModuleUserException TypeError 1176 15 StrictModuleUserException TypeError 330 27 StrictModuleUserException TypeError 546 16 StrictModuleUserException TypeError
---
test_dataclass_field_pos_arg
---
from dataclasses import field
f = field(1)
---
---
2 4 StrictModuleUnhandledException(TypeError)
---
test_dataclass_corrupted_annotation
---
from dataclasses import dataclass
class C:
    a: int
C.__annotations__[2] = 3
c = dataclass(C)
---
---
5 4 StrictModuleUnhandledException(TypeError) 1185 11 StrictModuleUserException TypeError 1176 15 StrictModuleUserException TypeError 299 30 StrictModuleUserException TypeError 173 14 StrictModuleUserException TypeError
---
test_dataclass_corrupted_fields
---
from dataclasses import dataclass
@dataclass
class C:
    a: int
C.__dataclass_fields__ = 1
@dataclass
class D(C):
    b: int
---
---
6 1 StrictModuleUnhandledException(AttributeError) 1185 11 StrictModuleUserException AttributeError 1176 15 StrictModuleUserException AttributeError 275 21 StrictModuleUserException AttributeError
---
test_dataclass_corrupted_fields_1
---
from dataclasses import dataclass
@dataclass
class C:
    a: int
C.__dataclass_fields__["b"] = 1
@dataclass
class D(C):
    b: int
---
---
6 1 StrictModuleUnhandledException(AttributeError) 1185 11 StrictModuleUserException AttributeError 1176 15 StrictModuleUserException AttributeError 276 23 StrictModuleUserException AttributeError
---
test_dataclass_init_var_post_init
---
from dataclasses import InitVar, dataclass, field
@dataclass
class C:
    a: int
    b: InitVar[int]
    c: int = field(init=False)
    def __post_init__(self, b):
        self.c = b

c = C(1, 2)
ca = c.a
cc = c.c
---
ca cc
---
---
test_dataclass_init_var_post_init_future_annotations
---
from __future__ import annotations
from dataclasses import InitVar, dataclass, field
@dataclass
class C:
    a: int
    b: InitVar[int]
    c: int = field(init=False)
    def __post_init__(self, b):
        self.c = b

c = C(1, 2)
ca = c.a
cc = c.c
---
ca cc
---
---
test_dataclass_init_var_not_field
---
from dataclasses import InitVar, dataclass, field
@dataclass
class C:
    a: int
    b: InitVar[int]
    c: int = field(init=False)
    def __post_init__(self, b):
        self.c = b

c = C(1, 2)
ca = c.a
cc = c.c
---
ca cc
---
---
test_dataclass_replace
---
from dataclasses import dataclass, replace
@dataclass
class C:
    a: int

c = C(1)
c1 = replace(c, a=2)
a = c1.a
---
a
---
---
test_dataclass_replace_non_dataclass
---
from dataclasses import replace
class C:
    a: int

c = C()
c1 = replace(c, a=2)
---
---
6 5 StrictModuleUnhandledException(TypeError) 1425 8 StrictModuleUserException TypeError
---
test_dataclass_replace_no_initvar
---
from dataclasses import dataclass, replace, InitVar
@dataclass
class C:
    a: int
    b: InitVar[int]

c = C(1, 2)
c1 = replace(c, a=2)
---
---
8 5 StrictModuleUnhandledException(ValueError) 1445 16 StrictModuleUserException ValueError
---
test_dataclass_replace_no_init
---
from dataclasses import dataclass, replace, field
@dataclass
class C:
    a: int
    b: int = field(init=False)

c = C(1)
c1 = replace(c, a=2, b=1)
---
---
8 5 StrictModuleUnhandledException(ValueError) 1438 16 StrictModuleUserException ValueError
---
test_dataclass_replace_partial
---
from dataclasses import dataclass, replace
@dataclass
class C:
    a: int
    b: int
c = C(1, 3)
c1 = replace(c, a=2)
a = c1.a
b = c1.b
---
a b
---
---
test_dataclass_replace_too_many_posarg
---
from dataclasses import dataclass, replace
@dataclass
class C:
    a: int
    b: int
c = C(1, 2)
d = replace(c, 1)
---
---
7 4 StrictModuleUnhandledException(TypeError)
---
test_dataclass_make
---
from dataclasses import make_dataclass
C = make_dataclass("C", ["x", "y"])
c = C(1, 2)
x = c.x
y = c.y
---
x y
---
---
test_dataclass_make_with_field
---
from dataclasses import make_dataclass, field
C = make_dataclass("C", ["x", ("y", int, field(init=False))])
c = C(1)
c.y = 2
x = c.x
y = c.y
---
x y
---
---
test_dataclass_make_with_namespace
---
from dataclasses import make_dataclass, field
C = make_dataclass(
    "C",
    ["x", ("y", int)],
    namespace = {"f": lambda self: self.y}
)
c = C(1, 2)
x = c.x
y = c.f()
---
x y
---
---
test_dataclass_make_with_bases
---
from dataclasses import make_dataclass, field, dataclass
@dataclass
class B:
    a: int

C = make_dataclass(
    "C",
    ["x", ("y", int)],
    bases = (B,)
)
c = C(1, 2, 3)
a = c.a
x = c.x
y = c.y
---
a x y
---
---
test_tuple_constructor
---
t1 = tuple()
t2 = tuple([1, 2])
x = t2[0]
---
t1 t2 x
---
---
test_tuple_constructor_non_iter
---
t1 = tuple(1)
---
---
1 5 StrictModuleUnhandledException(TypeError)
---
test_dict_constructor
---
d1 = dict()
d2 = dict([(1, 2)])
d3 = dict({1:2})
d4 = dict(a=1)
d5 = dict({1:2}, a=1)
---
d1 d2 d3 d4 d5
---
---
test_dict_bad_arg
---
d1 = dict((1, 2))
---
---
1 5 StrictModuleUnhandledException(TypeError)
---
test_dataclass_asdict
---
from dataclasses import dataclass, asdict
@dataclass
class C:
    a: int
    b: int
c = C(1, 2)
d = asdict(c)
---
d
---
---
test_dataclass_asdict_with_subclass
---
from dataclasses import dataclass, asdict
@dataclass
class C:
    a: int
    b: int
@dataclass
class D(C):
    x: int
c = D(1, 2, 3)
d = asdict(c)
---
d
---
---
test_dataclass_asdict_with_list_tuple
---
from dataclasses import dataclass, asdict
@dataclass
class C:
    a: object
    b: int
c = C([C(3, 4), 1], (5, 6))
d = asdict(c)
d_a = d["a"]
d_a_0 = d_a[0]
d_a_1 = d_a[1]
d_b = d["b"]
d_b_0 = d_b[0]
d_b_1 = d_b[1]
---
d_a_0 d_a_1 d_b_0 d_b_1
---
---
test_dataclass_asdict_with_namedtuple
---
from dataclasses import dataclass, asdict
from collections import namedtuple
@dataclass
class C:
    a: object

T = namedtuple("T", "x, y")
c = C(T(C(1), 2))
d = asdict(c)
d_a = d["a"]
d_a_0 = d_a[0]
d_a_1 = d_a[1]
---
d_a_0 d_a_1
---
---
test_dataclass_asdict_with_None
---
from dataclasses import dataclass, asdict
from typing import Optional
@dataclass
class C:
    a: int
    b: Optional[int]
c = C(1, None)
d = asdict(c)
---
d
---
---
test_dataclasses_fields
---
from dataclasses import dataclass, fields
@dataclass
class C:
    a: int
    b: int
fs = fields(C)
f0 = fs[0]
f1 = fs[1]
n0 = f0.name
n1 = f1.name
l = len(fs)
---
l n0 n1
---
---
test_dataclasses_fields_instance
---
from dataclasses import dataclass, fields
@dataclass
class C:
    a: int
    b: int
c = C(1, 2)
fs = fields(c)
f0 = fs[0]
f1 = fs[1]
n0 = f0.name
n1 = f1.name
l = len(fs)
---
l n0 n1
---
---
test_dataclasses_fields_pseudo_fields
---
from dataclasses import dataclass, fields, InitVar
@dataclass
class C:
    a: int
    b: int
    c: InitVar[int]
c = C(1, 2, 3)
fs = fields(c)
f0 = fs[0]
f1 = fs[1]
n0 = f0.name
n1 = f1.name
l = len(fs)
---
l n0 n1
---
---
test_typing_iterable
---
from typing import Iterable
t = Iterable[str]
n = t._name
args = t.__args__
params = t.__parameters__
---
n args params
---
---
test_typing_namedtuple
---
from typing import NamedTuple
Employee = NamedTuple('Employee', name=str, id=int)
employee = Employee('joe', 42)
name = employee.name
id = employee.id
---
name id
---
---
test_typing_namedtuple_fields
---
from typing import NamedTuple
Employee = NamedTuple('Employee', [('name', str), ('id', int)])
employee = Employee('joe', 42)
name = employee.name
id = employee.id
---
name id
---
---
test_typing_namedtuple_fields_and_kwargs
---
from typing import NamedTuple
Employee = NamedTuple('Employee', [('name', str), ('id', int)], name=str, id=int)
---
---
2 11 StrictModuleUnhandledException(TypeError) 329 8 StrictModuleUserException TypeError
---
test_typing_namedtuple_meta_no_get
---
from typing import NamedTupleMeta
NamedTupleMeta('foo', (), 42)
---
---
2 0 StrictModuleUnhandledException(AttributeError) 2268 16 StrictModuleUserException AttributeError
---
test_typing_namedtuple_inheritance
---
from typing import NamedTuple
class Employee(NamedTuple):
    name: str
    id: int

employee = Employee('joe', 42)
name = employee.name
id = employee.id
---
name id
---
---
test_typing_namedtuple_inheritance_empty
---
from typing import NamedTuple
class Employee(NamedTuple):
    pass

employee = Employee()
l = len(employee)
---
l
---
---
test_typing_typeddict
---
from typing import TypedDict
class Employee(TypedDict, total=False):
    age: int

employee = Employee(age=3)

age = employee["age"]
total = Employee.__total__
---
age total
---
---
test_typing_literal_single_value
---
from typing import Literal

Mode = Literal[2]
x = Mode.__args__[0]
---
x
---
---
test_typing_literal
---
from typing import Literal

Mode = Literal[1, 2]
x = Mode.__args__[0]
---
x
---
---
test_dataclass_classvar
---
from typing import ClassVar
from dataclasses import dataclass
@dataclass
class C:
    b: ClassVar[str]
    a: int
c = C(1)
a = c.a
---
a
---
---
test_dataclass_classvar_future_annotations
---
from __future__ import annotations
from typing import ClassVar
from dataclasses import dataclass
@dataclass
class C:
    b: ClassVar[str]
    a: int
c = C(1)
a = c.a
---
a
---
---
test_dataclass_classvar_default
---
from typing import ClassVar
from dataclasses import dataclass
@dataclass
class C:
    b: ClassVar[str] = 2
    a: int
c = C(1)
a = c.a
b = c.b
---
a b
---
---
test_dataclass_classvar_default_factory
---
from typing import ClassVar
from dataclasses import dataclass, field

def f():
    return "a"

@dataclass
class C:
    b: ClassVar[str] = field(default_factory=f)
    a: int
---
---
7 1 StrictModuleUnhandledException(TypeError) 1185 11 StrictModuleUserException TypeError 1176 15 StrictModuleUserException TypeError 299 30 StrictModuleUserException TypeError 201 12 StrictModuleUserException TypeError
---
test_dataclass_classvar_fields
---
from typing import ClassVar
from dataclasses import dataclass, fields
@dataclass
class C:
    a: int
    b: int
    c: ClassVar[int] = 3
c = C(1, 2)
fs = fields(c)
f0 = fs[0]
f1 = fs[1]
n0 = f0.name
n1 = f1.name
l = len(fs)
---
n0 n1 l
---
---
test_dataclass_classvar_replace
---
from typing import ClassVar
from dataclasses import dataclass, replace
@dataclass
class C:
    a: int
    b: int
    c: ClassVar[int] = 3
c = C(1, 2)
d = replace(c, c=4)
---
---
9 4 StrictModuleUnhandledException(TypeError) 1454 11 StrictModuleUserException TypeError
---
test_isinstance
---
class C:
    pass

class D(C):
    pass

class A:
    pass

class B:
    __class__ = A

c = C()
d = D()
b = B()
t1 = isinstance(c, C)
t2 = isinstance(d, D)
t3 = isinstance(d, C)
t4 = isinstance(c, D)
t5 = isinstance(d, (C, A))
t6 = isinstance(b, B)
t7 = isinstance([], list)
---
t1 t2 t3 t4 t5 t6 t7
---
---
test_isinstance_with_instance_check
---
class Meta(type):
    def __instancecheck__(cls, instance):
        return isinstance(instance, cls.__subclass__)

class C:
    pass

class D(metaclass=Meta):
    __subclass__ = (C,)

class E(D):
    pass

c = C()
d = D()
e = E()
t1 = isinstance(c, D) # yes
t2 = isinstance(d, D) # yes, since d.type == D
t3 = isinstance(c, E) # yes
t4 = isinstance(e, D) # no, since D.__subclass__ does not have D itself
---
t1 t2 t3 t4
---
---
test_isinstance_with_metaclass
---
class Meta(type):
    pass

class D(metaclass=Meta):
    pass

class E(D):
    pass

d = D()
e = E()
t1 = isinstance(d, D) # yes
t2 = isinstance(d, E) # no
t3 = isinstance(e, D) # yes
t4 = isinstance(e, E) # yes
---
t1 t2 t3 t4
---
---
test_isinstance_bad_type_arg
---
class D:
    pass

d = D()
t1 = isinstance(d, 1)
---
---
5 5 StrictModuleUnhandledException(TypeError)
---
test_isinstance_missing_arg
---
t1 = isinstance(1)
---
---
1 5 StrictModuleUnhandledException(TypeError)
---
test_issubclass
---
class C:
    pass

class D(C):
    pass

class A:
    pass

class B:
    __class__ = A

t1 = issubclass(C, C)
t2 = issubclass(D, D)
t3 = issubclass(D, C)
t4 = issubclass(C, D)
t5 = issubclass(D, (C, A))
t6 = issubclass(B, B)
t7 = issubclass(list, list)
---
t1 t2 t3 t4 t5 t6 t7
---
---
test_subclasscheck_bases
---
class C:
    def __init__(self, *bases):
        self.__bases__ = bases

t1 = object.__subclasscheck__(C(42))
t2 = object.__subclasscheck__(C(object))
---
t1 t2
---
---
test_subclasscheck_bases_raises_attr_error
---
class C:
    @property
    def __bases__(self):
        raise AttributeError('no way')

t1 = object.__subclasscheck__(C())
---
---
6 5 StrictModuleUnhandledException(TypeError)
---
test_subclasscheck_bad_raises_other_error
---
class C:
    @property
    def __bases__(self):
        raise ValueError

t1 = object.__subclasscheck__(C())
---
---
6 5 StrictModuleUnhandledException(ValueError) 4 8 StrictModuleUserException ValueError
---
test_subclasscheck_bad_bases
---
class C:
    __bases__ = 42

t1 = object.__subclasscheck__(C())
---
---
4 5 StrictModuleUnhandledException(TypeError)
---
test_subclasscheck_self_bad_bases
---
class MC(type):
    __bases__ = 42
class C(metaclass=MC):
    pass

t1 = C.__subclasscheck__(42)
---
---
6 5 StrictModuleUnhandledException(TypeError)
---
test_issubclass_bad_type
---
issubclass(42, object)
---
---
1 0 StrictModuleUnhandledException(TypeError)
---
test_issubclass_bad_derived
---
issubclass(object, 42)
---
---
1 0 StrictModuleUnhandledException(TypeError)
---
test_unknown_call_display_name
---
x = "abc".unknown_method(1)
---
---
1 4 StrictModuleUnhandledException(AttributeError)
---
test_star_args
---
def f(a, b):
    return a

def g(a, b):
    return b

w = f(*(1, 'abc'))
x = f(*('abc', 1))
y = g(*(1, 'abc'))
z = g(*('abc', 1))
---
w x y z
---
---
test_custom_len
---
class C:
    def __len__(self):
        return 3

c = C()
l = len(c)
---
l
---
---
test_iterable_len
---
l1 = len([])
l2 = len([1])
l3 = len((1,))
l4 = len((1, 2))
l5 = len({1:1})
l6 = len('ab')
---
l1 l2 l3 l4 l5 l6
---
---
test_len_not_implemented
---
class C:
    pass
len(C())
---
---
3 0 StrictModuleUnhandledException(TypeError)
---
test_bool
---
b1 = bool()
b2 = bool(1)
b3 = bool(0)
b4 = bool(1.1)
b5 = bool([])
b6 = bool([1])
b7 = bool(True)
b8 = bool(False)
b9 = bool("abc")
b10 = bool("")
class C:
    pass
class D:
    def __bool__(self):
        return False
c = C()
d = D()
b11 = bool(c)
b12 = bool(d)
b13 = bool(0.0)
b14 = bool(None)
---
b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12 b13 b14
---
---
test_conditional
---
b1 = 1 and 0
b2 = None and 1
b3 = "" or None
b4 = "" and None
b5 = 1 or 2
b6= [] or None or 1
class C:
    def __init__(self, x):
        self.x = x
    def __bool__(self):
        return self.x
c1 = C(True)
c2 = C(False)
c = c1 and c2
cx = c.x
b7 = not []
b8 = not [1]
class D:
    def __len__(self):
        return 1 + 1
b9 = D() and True
---
b1 b2 b3 b4 b5 b6 b7 b8 b9 cx
---
---
test_for_loop
---
l = [1, 2, 3, 4]
for i in l:
    pass
---
i
---
---
test_for_loop_body_0
---
l = [1, 2, 3, 4]
x = 0
for i in l:
    x = i
---
x
---
---
test_if
---
t = True
x = 0
if t:
    x = 1
else:
    x = 2
---
x
---
---
test_if_none
---
x = None
if x:
    y = 1
else:
    y = 2
---
y
---
---
test_for_loop_if
---
l = [[True, 1], [False, 2], [True, 3], [False, 4]]
x = 0
y = 0
for s in l:
    t = s[0]
    v = s[1]
    if t:
        x = v
    else:
        y = x
---
x y
---
---
test_for_loop_class_def
---
l = [1, 3, 4]
for s in l:
    class C:
        def f(self):
            return 1
a = C().f()
---
a
---
---
test_exception_construction
---
exc = Exception(1)
a = exc.args
---
a
---
---
test_attribute_error_construction
---
exc = AttributeError(1)
a = exc.args
---
a
---
---
test_attribute_error_try_catch
---
try:
    x = 1
    raise AttributeError(2)
except AttributeError as a:
    x = a.args[0]
else:
    x = 3
finally:
    y = 4
---
x y
---
---
test_attribute_error_type_try_catch
---
try:
    x = 1
    raise AttributeError
except AttributeError as a:
    x = 2
else:
    x = 3
finally:
    y = 4
---
x y
---
---
test_attribute_error_try_catch_all
---
try:
    x = 1
    raise AttributeError(2)
except:
    x = 2
else:
    x = 3
finally:
    y = 4
---
x y
---
---
test_attribute_error_try_catch_multi_level
---
try:
    x = 1
    try:
        raise Exception(3)
    except AttributeError as e:
        x = 2
except Exception as e:
    x = e.args[0]
else:
    x = 4
finally:
    y = 5
---
x y
---
---
test_attribute_raised_on_access
---
x = 1
try:
    x.foo
except AttributeError as e:
    x = 2
---
x
---
---
test_getattr_builtin
---
class C:
    a: int
c = C()
c.a = 1
a = getattr(c, "a")
---
a
---
---
test_getattr_non_string
---
class C:
    a: int
c = C()
c.a = 1
a = getattr(c, 1)
---
---
5 4 StrictModuleUnhandledException(TypeError)
---
test_getattr_raises_attr_error
---
class C:
    @property
    def x(self):
        raise AttributeError()
c = C()
a = getattr(c, "x", 42)
---
a
---
---
test_getattr_raises_other
---
class C:
    @property
    def x(self):
        raise TypeError()
c = C()
a = getattr(c, "x", 42)
---
---
6 4 StrictModuleUnhandledException(TypeError) 4 8 StrictModuleUserException TypeError
---
test_setattr_builtin
---
class C:
    a: int
c = C()
setattr(c, "a", 1)
a = c.a
---
a
---
---
test_setattr_non_string
---
class C:
    a: int
c = C()
setattr(c, 1, 2)
---
---
4 0 StrictModuleUnhandledException(TypeError)
---
test_hasattr_builtin
---
class C:
    a: int
c = C()
b1 = hasattr(c, "a")
c.a = 1
b2 = hasattr(c, "a")
---
b1 b2
---
---
test_hasattr_non_string
---
class C:
    a: int
c = C()
b = hasattr(c, 1)
---
---
4 4 StrictModuleUnhandledException(TypeError)
---
test_hasattr_raises_attr_error
---
class C:
    @property
    def x(self):
        raise AttributeError()
c = C()
a = hasattr(c, "x")
---
a
---
---
test_hasattr_raises_other
---
class C:
    @property
    def x(self):
        raise TypeError()
c = C()
a = hasattr(c, "x")
---
---
6 4 StrictModuleUnhandledException(TypeError) 4 8 StrictModuleUserException TypeError
---
test_math
---
a = b'abc'
b = b'def'
c = len(a + b)
d = c + 1
e = 1 + c
f = c / 1
g = 1 / c
---
c d e f g
---
---
test_div
---
a = b'abc'
b = b'def'
c = len(a + b)
d = c / 2
---
c d
---
---
test_float_math
---
a = b'abc'
b = b'def'
c = len(a + b)
d = c / 2
e = d + 1.0
---
e
---
---
test_float_math_rev
---
a = b'abc'
b = b'def'
c = len(a + b)
d = c / 2
e = 1 + d
---
e
---
---
test_complex_math @disabled
---
a = b'abc'
b = b'def'
c = len(a + b)
d = c / 2
e = 3j + d
---
e
---
---
test_complex_math_rev @disabled
---
a = b'abc'
b = b'def'
c = len(a + b)
d = c / 2
e = d + 3j
---
e
---
---
test_dict_copy
---
x = {'abc': 42}
y = x.copy()
y['abc'] = 'foo'
a = y['abc']
b = x['abc']
---
a b
---
---
test_dict_get
---
x = {'abc': 42}
y = x.get('abc')
z = x.get('dne')
---
y z
---
---
test_dict_get_default
---
x = {'abc': 42}
y = x.get('foo', 'bar')
---
y
---
---
test_dict_setdefault
---
x = {}
ret = x.setdefault(42, 'abc')
y = x[42]
---
y ret
---
---
test_dict_setdefault_exists
---
x = {42:'def'}
ret = x.setdefault(42, 'abc')
y = x[42]
---
y ret
---
---
test_dict_pop
---
x = {'abc': 42, 'foo': 'bar'}
y = x.pop('abc')
---
y
---
---
test_dict_pop_default
---
x = {'abc': 42, 'foo': 'bar'}
y = x.pop('quox', 'baz')
---
y
---
---
test_dict_pop_not_present
---
x = {'abc': 42, 'foo': 'bar'}
y = x.pop('baz')
---
---
2 4 StrictModuleUnhandledException(KeyError)
---
test_dict_update
---
x = {}
y = {'abc':42}
x.update(y)
y.update({'abc': 100})
---
x
---
---
test_dict_update_kw
---
x = {}
y = {'abc':42}
x.update(y, foo=100)
---
x
---
---
test_dict_update_kwonly
---
x = {}
x.update(abc=42)
---
x
---
---
test_dict_update_iterable
---
x = {}
x.update([(1, 2), ])
---
x
---
---
test_dict_update_non_iterable
---
x = {}
x.update(None)
---
---
2 0 StrictModuleUnhandledException(TypeError)
---
test_dict_update_non_iterable_entry
---
x = {}
x.update([None])
---
---
2 0 StrictModuleUnhandledException(TypeError)
---
test_dict_update_bad_entry_len
---
x = {}
x.update([(1, )])
---
---
2 0 StrictModuleUnhandledException(TypeError)
---
test_dict_getitem
---
d = {1:2}
y = d.__getitem__(1)
---
y
---
---
test_dict_getitem_error
---
d = {1:2}
y = d.__getitem__(2)
---
---
2 4 StrictModuleUnhandledException(KeyError)
---
test_dict_contains
---
d = {2:3}
x = d.__contains__(2)
y = d.__contains__(3)
---
x y
---
---
test_dict_getitem_unknown
---
from x import y
d = {1:2}
y = d.__getitem__(y)
---
---
3 4 UnknownValueAttributeException <y imported from x> __hash__
---
test_dict_contains_unknown
---
from x import y
d = {2:3}
x = d.__contains__(y)
---
---
3 4 UnknownValueAttributeException <y imported from x> __hash__
---
test_dict_subclass_getitem
---
class mydict(dict):
    def __getitem__(self, index):
        res = super().__getitem__(index)
        return res.upper()

d = mydict()
d['foo'] = 'bar'
x = d['foo']
---
x
---
---
test_dict_subclass_setitem
---
class mydict(dict):
    def __setitem__(self, index, value):
        return super().__setitem__(index, value.upper())

d = mydict()
d['foo'] = 'bar'
x = d['foo']
---
x
---
---
test_dict_subclass_missing
---
class mydict(dict):
    def __missing__(self, key):
        return key
d = mydict()
d['foo'] = 'bar'
x = d['foo']
y = d['zed']
---
x y
---
---
test_dict_subclass_missing_not_called
---
class mydict(dict):
    def __missing__(self, key):
        return key

    def __getitem__(self, key):
        return 1
d = mydict()
d['foo'] = 'bar'
x = d['foo']
y = d['zed']
---
x y
---
---
test_class_getitem
---
class C:
    def __class_getitem__(cls, index):
        return (cls.__name__, index)

x, y = C[42]
---
x y
---
---
test_class_getitem_inheritance
---
class C:
    def __class_getitem__(cls, index):
        return (cls.__name__, index)

class D(C): pass

x, y = D[42]
---
x y
---
---
test_class_getitem_mc
---
class MC(type):
    def __getitem__(self, index):
        return index + 1

class C:
    def __class_getitem__(cls, index):
        return (cls.__name__, index)

x, y = C[42]
---
x y
---
---
test_generic_dict
---
__name__ = 'abc'
from typing import DefaultDict, Generic, TypeVar
_KT = TypeVar("_KT")
_VT = TypeVar("_VT")

class FallbackDict(DefaultDict[_KT, _VT], Generic[_KT, _VT]):
    pass

fd  = FallbackDict()
---
---
---
test_dunder_class
---
x = 42
y = x.__class__
---
y
---
---
test_dunder_class_defined
---
class C:
    __class__ = 42

x = C().__class__
---
x
---
---
test_str_lower
---
x = 'ABC'.lower()
---
x
---
---
test_str_upper
---
x = 'abc'.upper()
---
x
---
---
test_str_encode
---
x = 'abc'.encode()
y = 'abc'.encode("utf-8")
---
x y
---
---
test_str_strip
---
x = ' abc '.strip()
---
x
---
---
test_str_strip_arg
---
x = 'babcb'.strip('b')
---
x
---
---
test_str_strip_bad_arg
---
x = 'babcb'.strip(42)
---
---
1 4 StrictModuleUnhandledException(TypeError)
---
test_str_join
---
x = ','.join(['abc','def'])
---
x
---
---
test_str_join_non_str
---
x = ','.join(['abc', 1])
---
---
1 4 StrictModuleUnhandledException(TypeError)
---
test_str_join_non_primary
---
x = ','.join(['abc', object()])
---
---
1 4 StrictModuleUnhandledException(TypeError)
---
test_str_format_no_args
---
x = 'Hello'.format()
---
x
---
---
test_str_format_multiple_args_safe
---
class Bar:
    def __str__(self):
        return "Bar"
x = '{} {key_arg} {}'.format(3, 'bla', key_arg=Bar())
---
---
---
test_str_format_safe_dunder_str_unsafe_dunder_repr
---
class Foo:
    def __str__(self):
        return "Foo"
    def __repr__(self):
        import random
        return str(random.random())
x = 'Hi {}'.format(Foo())
---
---
---
test_str_format_unsafe_dunder_str
---
class Foo:
    def __str__(self):
        return fake_func()
x = 'Hi {}'.format(Foo())
---
---
4 4 StrictModuleUnhandledException(NameError) 3 15 StrictModuleUserException NameError
---
test_str_format_unsafe_dunder_repr
---
class Foo:
    def __repr__(self):
        return fake_func()
x = 'Hi {}'.format(Foo())
---
---
4 4 StrictModuleUnhandledException(NameError) 3 15 StrictModuleUserException NameError
---
test_str_bad_index
---
x = "abc"[-5]
---
---
1 4 StrictModuleUnhandledException(TypeError)
---
test_str_unsupported_index
---
x = "abc"[0.0]
---
---
1 4 StrictModuleUnhandledException(TypeError)
---
test_str_slice_unsupported
---
x = "abc"[0.0:1]
---
---
1 4 StrictModuleUnhandledException(TypeError)
---
test_str_formatting
---
x = "%s" % ("foo", )
y = "%s/%s" % ("foo", "bar")
z = "%s/%s" % (42, "bar")
a = "%r/%r" % (1, 2)
---
x y z a
---
---
test_func_dict
---
def f(a):
    pass
f.__dict__['a'] = 2
a = f.__dict__['a']
---
a
---
---
test_func_annotations
---
def f(a: 42, b: int, *args: str, x:bool=False, **kwargs: list) -> None:
    pass
ann = f.__annotations__
a = ann['a']
b = ann['b']
args = ann['args']
x = ann['x']
kwargs = ann['kwargs']
ret = ann['return']
---
a b args x kwargs ann
---
---
test_func_no_defaults
---
def f(a, b) -> None:
    pass
defaults = f.__defaults__
kwdefaults = f.__kwdefaults__
---
defaults kwdefaults
---
---
test_func_defaults
---
def f(a = 1, b = 2) -> None:
    pass
defaults = f.__defaults__
a = defaults[0]
b = defaults[1]
---
a b defaults
---
---
test_func_kwdefaults
---
def f(*, a = 1) -> None:
    pass
kwdefaults = f.__kwdefaults__
a = kwdefaults["a"]
---
a kwdefaults
---
---
test_func_dict_non_string_key
---
def f(a):
    pass
f.__dict__[2] = 1
---
---
3 0 UnsupportedException function.__dict__.__setitem__ int
---
test_set_func_dict
---
def f(a):
    pass
f.__dict__ = {'a': 1}
a = f.__dict__['a']
---
a
---
---
test_set_func_dict_no_string
---
def f(a):
    pass
f.__dict__ = {'a': 1, 2: 2}
a = f.__dict__['a']
---
---
3 0 StrictModuleUnhandledException(TypeError)
---
test_reset_func_dict
---
def f(a):
    pass
f.__dict__['a'] = 2
a1 = f.__dict__['a']
f.__dict__ = {'a': 1}
a2 = f.__dict__['a']
---
a1 a2
---
---
test_dunder_dict_identity
---
def f(a):
    pass
d1 = f.__dict__
f.__dict__['a'] = 2
d2 = f.__dict__
b = d1 is d2
---
b
---
---
test_type_dict
---
class C:
    a: int = 2
a = C.__dict__['a']
---
a
---
---
test_set_type_dict
---
class C:
    a: int = 2
C.__dict__ = {'a': 1}
d = C.__dict__
---
---
3 0 StrictModuleUnhandledException(AttributeError)
---
test_type_mro
---
x = int.__mro__[0]
---
x
---
---
test_super_basic
---
class C:
    def f(self):
        return 1
class D(C):
    def f(self):
        return super(D, self).f()
a = D().f()
---
a
---
---
test_super_outside_class
---
class C:
    def f(self):
        return 1
class D(C):
    def f(self):
        return 2
a = super(D, D()).f()
b = D().f()
---
a b
---
---
test_super_single_inheritance_search
---
class C:
    def f(self):
        return 1
class D(C):
    def f(self):
        return 2

class E(D):
    pass
a = super(E, E()).f() # D.f
b = super(D, E()).f() # C.f
c = super(D, D()).f() # C.f
---
a b c
---
---
test_super_not_subtype
---
class C:
    def f(self):
        return 1
class D(C):
    def f(self):
        return 2

super(D, C()).f()
---
---
8 0 StrictModuleUnhandledException(TypeError)
---
test_super_descr_get
---
class C:
    def f(self):
        return 1
class D(C):
    def f(self):
        return 2

s = super(D)
class E(D):
    mysuper = s
a = E().mysuper.f() # invoke s.__get__(E()).f() -> super(D, E()).f() = 1
---
a
---
---
test_super_base_call
---
class C:
    def f(self):
        return 1
class D(C):
    def f(self):
        return super(D, self).f()

a = D().f()
---
a
---
---
test_super_unknown_base
---
from outside import unknown
class A:
    def f(self):
        return 1
class C(unknown, A):
    def __new__(cls, *args, **kwargs):
        obj = object.__new__(cls, *args, **kwargs)
        return obj

    def __init__(self):
        pass
c = C()
super(A, c).f()
---
---
13 0 StrictModuleUnhandledException(AttributeError)
---
test_super_multiple_inheritance
---
class A:
    def f(self):
        return 1
class B(A):
    def f(self):
        return 2

class C(A):
    def f(self):
        return 3

class D(B, C): # DBCA
    pass

a = super(D, D()).f()
b = super(C, D()).f()
c = super(B, D()).f()
---
a b c
---
---
test_super_multiple_inheritance_2
---
class A:
    def f(self):
        return 1
class B(A):
    def f(self):
        return super(B, self).f()

class C(A):
    def f(self):
        return 3

class D(B, C): # DBCA
    def f(self):
        return super(D, self).f()

a = super(D, D()).f()
b = super(C, D()).f()
c = super(B, D()).f()
d = super(B, B()).f()
---
a b c d
---
---
test_super_multiple_inheritance_3
---
class A:
    def f(self):
        return 4
class B(A): # BA
    def f(self):
        return 10 * (super(B, self).f()) + 1

class C(A): # CA
    def f(self):
        return 10 * (super(C, self).f()) + 2

class D(B, C): # DBCA
    def f(self):
        return 10 * (super(D, self).f()) + 3

a = D().f()
---
a
---
---
test_dunder_class_cell
---
class A:
    def f(self):
        return __class__

class B(A):
    def f(self):
        return super(B, self).f()

    def g(self):
        return __class__
a = A().f() == A
b = B().f() == A
c = B().g() == B
---
a b c
---
---
test_magical_super_multiple_inheritance
---
class A:
    def f(self):
        return 4
class B(A): # BA
    def f(self):
        return 10 * (super().f()) + 1

class C(A): # CA
    def f(self):
        return 10 * (super().f()) + 2

class D(B, C): # DBCA
    def f(self):
        return 10 * (super().f()) + 3

a = D().f()
---
a
---
---
test_magical_super_outside_method
---
class A:
    def f(self):
        return 1
class B(A):
    pass
__class__ = B
def f(self):
    return super().f() # should not use __class__
f(B())
---
---
9 0 StrictModuleUnhandledException(RuntimeError) 8 11 StrictModuleUserException RuntimeError
---
test_super_shadow_dunder_class
---
class B:
    def f(self): return 1
class C(B):
    def f(self):
        return super().f()
    __class__ = 2

a = C().f()
---
a
---
---
test_callable
---
def f():
    pass
class A:
    pass
class B:
    def g(self):
        return 1
class C:
    def __call__(self):
        pass
c = C()
b1 = callable(f)
b2 = callable(A)
b3 = callable(B)
b4 = callable(A())
b5 = callable(B.g)
b6 = callable(B().g)
b7 = callable(B().g())
b8 = callable(C)
b9 = callable(c)
---
b1 b2 b3 b4 b5 b6 b7 b8 b9
---
---
test_callable_on_unknown
---
import unknown
b = callable(unknown)
---
---
---
test_dunder_call
---
class B:
    def __call__(self):
        return 1
b = B()
a = b()
x = a == 1
---
x
---
---
test_list_add
---
l1 = [1, 2]
l2 = [1, 3]
l3 = [1, 2] + [1, 3]
l4 = l1 + l2
---
l3 l4
---
---
test_list_multiply
---
l1 = [1, 2]
l2 = l1 * 3
l3 = [] * 3
---
l2 l3
---
---
test_list_eq
---
l1 = [1, 2, 3]
l2 = [1, 2]
b1 = l1 == l2
l2.append(3)
b2 = l1 == l2
---
b1 b2
---
---
test_list_eq_subclass
---
class MyList(list):
    pass
l1 = MyList()
b1 = l1 == []
b2 = [] == l1
b3 = l1 == [1]
b4 = [1] == l1
l1.append(1)
b5 = l1 == [1]
b6 = [1] == l1
---
b1 b2 b3 b4 b5 b6
---
---
test_list_add_subclass
---
class MyList(list):
    pass
x = MyList() + [1]
---
x
---
---
test_list_radd_subclass
---
class MyList(list):
    pass
x = [1] + MyList()
---
x
---
---
test_list_set_item
---
l = [1, 2, 3, 4, 5]
l[0] = 0
x = l[0] == 0
l[-2] = -1
y = l[3] == -1
l[:] = []
---
x y l
---
---
test_tuple_add
---
l1 = (1, 2)
l2 = (1, 3)
l3 = (1, 2) + (1, 3)
l4 = l1 + l2
---
l3 l4
---
---
test_tuple_add_subclass
---
class MyTuple(tuple):
    pass
x = MyTuple() + (1, 2)
---
x
---
---
test_tuple_radd_subclass
---
class MyTuple(tuple):
    pass
x = (1, 2) + MyTuple()
---
x
---
---
test_tuple_eq
---
b1 = () == ()
b2 = () == (1,)
b3 = (1,) == (1,)
b4 = (1,2,3) == (1,2,3)
---
b1 b2 b3 b4
---
---
test_tuple_eq_subclass
---
class MyTuple(tuple):
    pass
l1 = MyTuple()
b1 = l1 == ()
b2 = l1 == (1,)
b3 = () == l1
b4 = (1, ) == l1
---
b1 b2 b3 b4
---
---
test_tuple_index
---
x = (1, 2)[0]
---
x
---
---
test_tuple_slice
---
x = (1, 2, 3, 4)[0:2]
---
x
---
---
test_tuple_bad_slice
---
x = (1, 2, 3, 4)['abc']
---
---
1 4 StrictModuleUnhandledException(TypeError)
---
test_tuple_bad_index
---
x = (1, 2)[-5]
---
---
1 4 StrictModuleUnhandledException(TypeError)
---
test_int_multiple_compare
---
x = 10
b = 1 < x < 100 > 5
c = 1 < x > 5
d = 1 < x == 10 > 100
---
b c d
---
---
test_star_assignment
---
x = [1, 2, 3, 4]
a, *b, c, d = x
e, *f = x
*g, = x
*h, i = x
j, *k, l = x
m, n, *o, p, q = x
---
a b c d e f g h i j k l m n o p q
---
---
test_call_functions
---
def f(a, b, c):
    return a + b + c

def g(a, b, *args):
    return a + b + args[0]

def h(a, b, *args, c, d, **kwargs):
    return a + b + d + kwargs["f"]

def j(f, /, **kwargs):
    return f + kwargs["f"]

x = f(1, b=2, c=3)
y = g(1, 2, 3, 4, 5)
z = h(1, 2, 3, 4, c = 5, d = 6, e = 7, f = 8)
w = j(2, f=3)
---
x y z w
---
---
test_function_member_get
---
def f(x):
    "something"
    return x
a = f.__name__
b = f.__qualname__
c = f.__module__
d = f.__doc__
---
a b c
---
---
test_function_member_set
---
def f(x):
    "something"
    return x
f.__name__ = "g"
f.__qualname__ = "x.y"
f.__module__ = "m"
f.__doc__ = "something"
a = f.__name__
b = f.__qualname__
c = f.__module__
d = f.__doc__
---
a b c d
---
---
test_function_member_deletion_allowed
---
def f(x):
    return x
f.__module__ = "m"
f.__doc__ = "something"
a = f.__module__
b = f.__doc__
del f.__module__
del f.__doc__
c = f.__module__
d = f.__doc__
---
a b c d
---
---
test_function_member_deletion_disallowed
---
def f(x):
    return x

del f.__name__
---
---
4 0 StrictModuleUnhandledException(TypeError)
---
test_set_init
---

s1 = set()
s2 = set([1, 2])
s3 = set(s2)
s4 = set()
s4.__init__([2, 3, 4])
l1 = len(s1)
l2 = len(s2)
l3 = len(s3)
l4 = len(s4)
---
s1 s2 s3 s4 l1 l2 l3 l4
---
---
test_set_init_too_many_args
---
s1 = set(1, 2)
---
---
1 5 StrictModuleUnhandledException(TypeError)
---
test_set_init_not_iterable
---
s1 = set(1)
---
---
1 5 StrictModuleUnhandledException(TypeError)
---
test_set_methods
---
s = set([1, 2])
l1 = len(s)
s.add(3)
l2 = len(s)
s.add(1)
l3 = len(s)
s.update([5, 6])
l4 = len(s)
s.update([5, 6])
l5 = len(s)
s.pop()  # cannot guarantee the same element popped
l6 = len(s)
b1 = set().issubset(s)
b2 = set() <= s
b3 = s <= set()
---
l1 l2 l3 l4 l5 l6 b1 b2 b3
---
---
test_frozenset_init
---
s1 = frozenset()
s2 = frozenset([1, 2])
s3 = frozenset(s2)
s4 = frozenset()
l1 = len(s1)
l2 = len(s2)
l3 = len(s3)
l4 = len(s4)
---
s1 s2 s3 l1 l2 l3 l4
---
---
test_frozenset_init_too_many_args
---
s1 = frozenset(1, 2)
---
---
1 5 StrictModuleUnhandledException(TypeError)
---
test_frozenset_init_not_iterable
---
s1 = frozenset(1)
---
---
1 5 StrictModuleUnhandledException(TypeError)
---
test_set_frozenset_binop
---
l = set([1, 2])
r = frozenset([3, 4])
x = l | r
y = r | l
a = type(x) == set
b = type(y) == frozenset
---
x y a b
---
---
test_iscoroutinefunction @disabled
---
from asyncio import iscoroutinefunction
def f():
    pass

async def g():
    pass

class C:
    def h(self):
        pass
    async def j(self):
        pass

c = C()
b1 = iscoroutinefunction(f)
b2 = iscoroutinefunction(g)
b3 = iscoroutinefunction(C.h)
b4 = iscoroutinefunction(C.j)
b5 = iscoroutinefunction(c.h)
b6 = iscoroutinefunction(c.j)
---
b1 b2 b3 b4 b5 b6
---
---
test_asyncio_Lock @disabled
---
from asyncio import Lock
---
---
---
test_asyncio_Lock_unknown @disabled
---
from asyncio import Lock
x = lock.foo
---
---
UnknownValueAttributeException
---
test_private_name_in_class_with_underscore
---
class __C__:
    __x = 1
    def f():
        return __C__.__x;
x = __C__.f()
---
x
---
---
test_comprehension
---
l1 = [1, 2, 3]
l2 = [6, 7, 8]
l3 = [[1, 2, 3], [4, 5, 6]]
z1 = [(x, y) for x in l1 for y in l2]
z2 = [w for j in l3 for w in j]
z3 = [v for k in z1 for v in k]
z4 = [u for m in z1 for u in m if u > 1 and u < 8]
z5 = tuple(a for a in l1)
z6 = tuple(w for j in l3 for w in j)
---
z1 z2 z3 z4 z5 z6
---
---
test_functools_wraps @disabled
---
def recursive_repr(fillvalue='...'):
    """Decorator to make a repr function return fillvalue for a recursive call"""

    def decorating_function(user_function):
        repr_running = set()

        def wrapper(self):
            key = id(self), get_ident()
            if key in repr_running:
                return fillvalue
            repr_running.add(key)
            try:
                result = user_function(self)
            finally:
                repr_running.discard(key)
            return result
        wrapper.__module__ = getattr(user_function, '__module__')
        wrapper.__doc__ = getattr(user_function, '__doc__')
        wrapper.__name__ = getattr(user_function, '__name__')
        wrapper.__qualname__ = getattr(user_function, '__qualname__')
        wrapper.__annotations__ = getattr(user_function, '__annotations__', {})
        return wrapper
    return decorating_function
WRAPPER_ASSIGNMENTS = ('__module__', '__name__', '__qualname__', '__doc__',
    '__annotations__')
WRAPPER_UPDATES = '__dict__',


def update_wrapper(wrapper, wrapped, assigned=WRAPPER_ASSIGNMENTS, updated=
    WRAPPER_UPDATES):
    """Update a wrapper function to look like the wrapped function

       wrapper is the function to be updated
       wrapped is the original function
       assigned is a tuple naming the attributes assigned directly
       from the wrapped function to the wrapper function (defaults to
       functools.WRAPPER_ASSIGNMENTS)
       updated is a tuple naming the attributes of the wrapper that
       are updated with the corresponding attribute from the wrapped
       function (defaults to functools.WRAPPER_UPDATES)
    """
    for attr in assigned:
        try:
            value = getattr(wrapped, attr)
        except AttributeError:
            pass
        else:
            setattr(wrapper, attr, value)
    for attr in updated:
        getattr(wrapper, attr).update(getattr(wrapped, attr, {}))
    wrapper.__wrapped__ = wrapped
    return wrapper


def wraps(wrapped, assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES):
    """Decorator factory to apply update_wrapper() to a wrapper function

       Returns a decorator that invokes update_wrapper() with the decorated
       function as the wrapper argument and the arguments to wraps() as the
       remaining arguments. Default arguments are as for update_wrapper().
       This is a convenience function to simplify applying partial() to
       update_wrapper().
    """
    return partial(update_wrapper, wrapped=wrapped, assigned=assigned,
        updated=updated)


class partial:
    """New function with partial application of the given arguments
    and keywords.
    """
    __slots__ = 'func', 'args', 'keywords', '__dict__', '__weakref__'

    def __new__(cls, func, /, *args, **keywords):
        if not callable(func):
            raise TypeError('the first argument must be callable')
        if hasattr(func, 'func'):
            args = func.args + args
            keywords = {**func.keywords, **keywords}
            func = func.func
        self = super(partial, cls).__new__(cls)
        self.func = func
        self.args = args
        self.keywords = keywords
        return self

    def __call__(self, /, *args, **keywords):
        keywords = {**self.keywords, **keywords}
        return self.func(*self.args, *args, **keywords)

    @recursive_repr()
    def __repr__(self):
        qualname = type(self).__qualname__
        args = [repr(self.func)]
        args.extend(repr(x) for x in self.args)
        args.extend(f'{k}={v!r}' for k, v in self.keywords.items())
        if type(self).__module__ == 'functools':
            return f"functools.{qualname}({', '.join(args)})"
        return f"{qualname}({', '.join(args)})"

    def __reduce__(self):
        return type(self), (self.func,), (self.func, self.args, self.
            keywords or None, self.__dict__ or None)

    def __setstate__(self, state):
        if not isinstance(state, tuple):
            raise TypeError('argument to __setstate__ must be a tuple')
        if len(state) != 4:
            raise TypeError(f'expected 4 items in state, got {len(state)}')
        func, args, kwds, namespace = state
        if not callable(func) or not isinstance(args, tuple
            ) or kwds is not None and not isinstance(kwds, dict
            ) or namespace is not None and not isinstance(namespace, dict):
            raise TypeError('invalid partial state')
        args = tuple(args)
        if kwds is None:
            kwds = {}
        elif type(kwds) is not dict:
            kwds = dict(kwds)
        if namespace is None:
            namespace = {}
        self.__dict__ = namespace
        self.func = func
        self.args = args
        self.keywords = kwds


def _gt_from_lt(self, other, NotImplemented=NotImplemented):
    """Return a > b.  Computed by @total_ordering from (not a < b) and (a != b)."""
    op_result = self.__lt__(other)
    if op_result is NotImplemented:
        return op_result
    return not op_result and self != other


def _le_from_lt(self, other, NotImplemented=NotImplemented):
    """Return a <= b.  Computed by @total_ordering from (a < b) or (a == b)."""
    op_result = self.__lt__(other)
    return op_result or self == other


def _ge_from_lt(self, other, NotImplemented=NotImplemented):
    """Return a >= b.  Computed by @total_ordering from (not a < b)."""
    op_result = self.__lt__(other)
    if op_result is NotImplemented:
        return op_result
    return not op_result


def _ge_from_le(self, other, NotImplemented=NotImplemented):
    """Return a >= b.  Computed by @total_ordering from (not a <= b) or (a == b)."""
    op_result = self.__le__(other)
    if op_result is NotImplemented:
        return op_result
    return not op_result or self == other


def _lt_from_le(self, other, NotImplemented=NotImplemented):
    """Return a < b.  Computed by @total_ordering from (a <= b) and (a != b)."""
    op_result = self.__le__(other)
    if op_result is NotImplemented:
        return op_result
    return op_result and self != other


def _gt_from_le(self, other, NotImplemented=NotImplemented):
    """Return a > b.  Computed by @total_ordering from (not a <= b)."""
    op_result = self.__le__(other)
    if op_result is NotImplemented:
        return op_result
    return not op_result


def _lt_from_gt(self, other, NotImplemented=NotImplemented):
    """Return a < b.  Computed by @total_ordering from (not a > b) and (a != b)."""
    op_result = self.__gt__(other)
    if op_result is NotImplemented:
        return op_result
    return not op_result and self != other


def _ge_from_gt(self, other, NotImplemented=NotImplemented):
    """Return a >= b.  Computed by @total_ordering from (a > b) or (a == b)."""
    op_result = self.__gt__(other)
    return op_result or self == other


def _le_from_gt(self, other, NotImplemented=NotImplemented):
    """Return a <= b.  Computed by @total_ordering from (not a > b)."""
    op_result = self.__gt__(other)
    if op_result is NotImplemented:
        return op_result
    return not op_result


def _le_from_ge(self, other, NotImplemented=NotImplemented):
    """Return a <= b.  Computed by @total_ordering from (not a >= b) or (a == b)."""
    op_result = self.__ge__(other)
    if op_result is NotImplemented:
        return op_result
    return not op_result or self == other


def _gt_from_ge(self, other, NotImplemented=NotImplemented):
    """Return a > b.  Computed by @total_ordering from (a >= b) and (a != b)."""
    op_result = self.__ge__(other)
    if op_result is NotImplemented:
        return op_result
    return op_result and self != other


def _lt_from_ge(self, other, NotImplemented=NotImplemented):
    """Return a < b.  Computed by @total_ordering from (not a >= b)."""
    op_result = self.__ge__(other)
    if op_result is NotImplemented:
        return op_result
    return not op_result


_convert = {'__lt__': [('__gt__', _gt_from_lt), ('__le__', _le_from_lt), (
    '__ge__', _ge_from_lt)], '__le__': [('__ge__', _ge_from_le), ('__lt__',
    _lt_from_le), ('__gt__', _gt_from_le)], '__gt__': [('__lt__',
    _lt_from_gt), ('__ge__', _ge_from_gt), ('__le__', _le_from_gt)],
    '__ge__': [('__le__', _le_from_ge), ('__gt__', _gt_from_ge), ('__lt__',
    _lt_from_ge)]}


def total_ordering(cls):
    """Class decorator that fills in missing ordering methods"""
    roots = {op for op in _convert if getattr(cls, op, None) is not getattr
        (object, op, None)}
    if not roots:
        raise ValueError(
            'must define at least one ordering operation: < > <= >=')
    root = max(roots)
    for opname, opfunc in _convert[root]:
        if opname not in roots:
            setattr(cls, opname, opfunc)
    return cls


for v in _convert.values():
    for opname, opfunc in v:
        opfunc.__name__ = opname


def _lru_cache_wrapper(user_function, maxsize, typed, _CacheInfo):

    def wrapper(*args, **kwds):
        raise Exception(
            'lru cache cannot be called at the top-level in a strict module')
    return wrapper


def lru_cache(maxsize=128, typed=False):
    """Least-recently-used cache decorator.

    If *maxsize* is set to None, the LRU features are disabled and the cache
    can grow without bound.

    If *typed* is True, arguments of different types will be cached separately.
    For example, f(3.0) and f(3) will be treated as distinct calls with
    distinct results.

    Arguments to the cached function must be hashable.

    View the cache statistics named tuple (hits, misses, maxsize, currsize)
    with f.cache_info().  Clear the cache and statistics with f.cache_clear().
    Access the underlying function with f.__wrapped__.

    See:  http://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)

    """
    if isinstance(maxsize, int):
        if maxsize < 0:
            maxsize = 0
    elif callable(maxsize) and isinstance(typed, bool):
        user_function, maxsize = maxsize, 128
        wrapper = _lru_cache_wrapper(user_function, maxsize, typed, _CacheInfo)
        return update_wrapper(wrapper, user_function)
    elif maxsize is not None:
        raise TypeError(
            'Expected first argument to be an integer, a callable, or None')

    def decorating_function(user_function):
        wrapper = _lru_cache_wrapper(user_function, maxsize, typed, _CacheInfo)
        return update_wrapper(wrapper, user_function)
    return decorating_function

def h(a):
    return a or False

def invert_h(a):
    b = h(a)
    return not b
update_wrapper(invert_h, h)
b1 = invert_h(None)
b2 = invert_h.__wrapped__(None)

def f(a, b, c):
    return a + b - c

fc = partial(f, a=1, b=2)
x1 = fc(c = 3)
x2 = fc(c = 0)
f.__dict__ = {"a": 1, "b": 2}
@wraps(f)
def g(*args):
    return f(*args)
a = g.__dict__["a"]
b = g.__dict__["b"]
---
b1 b2 x1 x2 a b
---
---
test_str_init
---
x = str("foo")

class C:
    def __str__(self):
        return "bar"

c = str(C())

d = str()
---
x c d
---
---
test_str_init_non_string
---
class C:
    def __str__(self):
        return 1

str(C())
---
---
5 0 StrictModuleUnhandledException(TypeError)
---
test_str_compare
---
b1 = "" > ""
b2 = "a" == "a"
b3 = "A" < "a"
b4 = "foo" < "bar"
b5 = "bar" < "baz"
b6 = "abc" < "bbc" > "bac"
b7 = "abc" in "abc"
b8 = "a" in "abc"
b9 = "a" in ""
b10 = "abc" not in "abc"
---
b1 b2 b3 b4 b5 b6 b7 b8 b9 b10
---
---
test_str_subclass_compare
---
class C(str):
    pass

class D(str):
    def __str__(self):
        return "ab"

class E(str):
    def __gt__(self, other):
        return True


b1 = C() > ""
b2 = D() > "a"
b3 = D() > "b"
b4 = E() > 1
b5 = E() > ""
b6 = E() < "a"
b7 = "" > C()
b8 = "a" > D()
b9 = "b" > D()
b10 = 1 < E()
b11 = "" > E()
b12 = "a" < E()
---
b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12
---
---
test_min_max
---
x1 = max(1, 2)
x2 = max(1, 2, 3, 4, 3, 2, 1)
def f(a):
    return -a
x3 = max(3, 2, 4, key=f)
x4 = max([], default=1)
x5 = max([1, 2, 3, 2, 1])
x6 = max([3, 2, 1], default=0)
x7 = max([2, 5, 1, 4], key=f)
x8 = min(3, 1, 2)
x9 = min([3, 1, 5, 4, 2])
x10 = max("a", "b", "o", "u", "about")
---
x1 x2 x3 x4 x5 x6 x7 x8 x9 x10
---
---
test_max_iterable_no_default
---
x = max([])
---
---
1 4 StrictModuleUnhandledException(ValueError)
---
test_not_implemented
---
def f():
    return NotImplemented
a = f()
---
a
---
---
test_star_in_list
---
l1 = [2, 3]
l2 = [1, *l1, 5]
---
l2
---
---
test_cast
---
from typing import cast
x = cast(int, 1)
y = cast(str, 2) # no runtime conversion
---
x y
---
---
test_dict_view
---
d = {1:2, 3:4}
k = d.keys()
v = d.values()
i = d.items()
l1 = {i for i in k}
l2 = {i for i in v}
l3 = {i+j for i, j in i}
d.update({5:6})
l4 = {i for i in k}
l5 = {i for i in v}
l6 = {i+j for i, j in i}
---
l1 l2 l3 l4 l5 l6
---
---
test_loop_continue
---
a, b = 0, 0
for i in [1, 2, 3]:
    a = i
    if a > 1:
        continue
    b = i
---
a b
---
---
test_loop_break
---
a, b = 0, 0
for i in [1, 2, 3]:
    a = i
    if a > 1:
        break
    b = i
---
a b
---
---
test_contains_iterable
---
l1 = [1, '2' ,'3']
l2 = (1, '2', '3')
b1 = 1 in l1
b2 = 4 in l1
b3 = '2' in l2
b4 = 5 in l2
b5 = '2' not in l1
b6 = 4 not in l1
b7 = '3' not in l2
b8 = 5 not in l2
class C:
    def __init__(self, v):
        self.v = v
    def __contains__(self, item):
        return item < self.v
b9 = 1 in C(2)
b10 = 2 in C(2)
c1 = C(1)
c2 = C(2)
c3 = C(1)
l3 = [c1, c2]
x = l3[0]
b11 = c1 in l3
b12 = c3 in l3
b13 = 1025 in [1025, 1026]
b14 = 1 not in C(2)
b15 = 2 not in C(2)
---
b3
---
---
test_contains_unsupported
---
class C:
    pass
1 in C()
---
---
3 0 StrictModuleUnhandledException(TypeError)
---
test_rich_comparison_eq_ne
---
class A:
    def __eq__(self, other):
        return 1
class B:
    def __eq__(self, other):
        return 2
class C(A):
    def __eq__(self, other):
        return 0
    def __ne__(self, other):
        return 4
class D:
    def __eq__(self, other):
        return NotImplemented
class E:
    pass
e = E()

x0 = A() == A()
x1 = A() == B()
x2 = A() == C()
x3 = B() == C()
x4 = A() != B()
x5 = A() != C()
x6 = B() != C()
x7 = C() != B()
x8 = D() != C()
x9 = E() == E()
x10 = e == e
x11 = E() != E()
x12 = e != e
---
x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12
---
---
test_rich_comparison
---
class A:
    def __le__(self, other):
        return 1
class B:
    def __le__(self, other):
        return 2
class C(A):
    def __ge__(self, other):
        return 3
class D:
    pass

class E:
    def __le__(self, other):
        return NotImplemented
x1 = A() <= B()
x2 = B() <= A()
x3 = A() <= C()
x4 = B() <= C()
x5 = D() <= C()
x6 = A() >= A()
x7 = A() >= B()
x8 = B() >= A()
x9 = E() <= C()
---
x1 x2 x3 x4 x5 x6 x7 x8 x9
---
---
test_while_loop
---
x = 1
while x < 100:
    x = x + 1
y = 1
while y > 100:
    y = y - 1
---
x y
---
---
test_while_loop_else
---
x = 1
while x < 100:
    x = x + 1
else:
    y = 1
---
x y
---
---
test_while_loop_continue
---
x = y = 1

while x < 100:
    x = x + 1
    if x > 50:
        continue
    y = y + 1
---
x y
---
---
test_while_loop_break
---
x = 1
while x < 100:
    x = x + 1
    if x > 50:
        break
else:
    x = 99
y = 1
while y < 50:
    y = y + 1
    if y > 50:
        break
else:
    y = 99
---
x y
---
---
test_rich_comparison_not_implemented
---
class A:
    def __le__(self, other):
        return NotImplemented
class B:
    pass

A() <= B()
---
---
7 0 StrictModuleUnhandledException(TypeError)
---
test_fstring_empty
---
s = f'abc'
---
s
---
---
test_fstring_join_unknown
---
from m import a
s = f'{a}'
---
---
2 4 UnknownValueAttributeException <a imported from m> __format__
---
test_fstring_simple
---
x = 'foo'
s = f'{x}'
---
s
---
---
test_fstring_unsupported_conversion
---
x = 'foo'
s = f'{x!a}'
---
---
2 4 UnsupportedException 'joined str to ascii' foo
---
test_fstring_str_conversion
---
x = 'foo'
s = f'{x!s}'
---
s
---
---
test_fstring_repr_conversion
---
class C:
    def __str__(self):
        return 'C'
    def __repr__(self):
        return 'obj'
s = f'{C()!r}'
---
s
---
---
test_fstring_str_format_spec
---
x = 'foo'
s = f'{x:5}'
---
s
---
---
test_fstring_str_conversion_from_int
---
x = 42
s = f'{x!s}'
---
s
---
---
test_fstring_int
---
x = 42
s = f'{x}'
---
s
---
---
test_fstring_format_spec
---
s = f'{42:3}'
---
s
---
---
test_int_format_err
---
(1).__format__("r")
---
---
1 0 StrictModuleUnhandledException(ValueError)
---
test_type_str
---
x = type("abc")
---
x
---
---
test_type_none
---
x = type(None)
---
x
---
---
test_function_call_exception
---
import unknown
def f():
    unknown.g()
x = f()
---
---
4 4 UnsafeCallException f 3 4 UnknownValueAttributeException <imported module unknown> g
---
test_with_enter
---
class A:
    def __enter__(self):
        return 1
    def __exit__(self, exc_tp, exc, tb):
        pass
with A() as a:
    pass
---
a
---
---
test_with_exit
---
class A:
    x = 1
    def __enter__(self):
        return self
    def __exit__(self, exc_tp, exc, tb):
        self.x = 2
with A() as a:
    pass
x = a.x
---
x
---
---
test_with_exit_exception
---
class A:
    def __enter__(self):
        pass
    def __exit__(self, exc_tp, exc, tb):
        pass
x = 2
try:
    with A() as a:
        raise Exception()
except Exception:
    x = 1
---
x
---
---
test_with_exit_suppress_exception
---
class A:
    def __enter__(self):
        pass
    def __exit__(self, exc_tp, exc, tb):
        return True
x = 2
try:
    with A() as a:
        raise Exception()
except Exception:
    x = 1
---
x
---
---
test_with_multiple_context_managers
---
l = []
class A:
    def __enter__(self):
        l.append(1)
    def __exit__(self, exc_tp, exc, tb):
        l.append(2)
class B:
    def __enter__(self):
        l.append(3)
    def __exit__(self, exc_tp, exc, tb):
        l.append(4)
with A(), B():
    l.append(5)
---
l
---
---
test_with_return_from_context_manager
---
l = []
class A:
    def __enter__(self):
        l.append(1)
    def __exit__(self, exc_tp, exc, tb):
        l.append(2)
def f():
    with A():
        return 3
b = f()
---
l b
---
---
test_list_ctor
---
l = [1, 2]
l1 = list(l)
---
l l1
---
---
test_list_ctor_non_iterable
---
l = list(42)
---
---
1 4 StrictModuleUnhandledException(TypeError)
---
test_enumerate
---
l = [1, 2]
enum = list(enumerate(l))
---
enum
---
---
test_enumerate_non_iterable
---
enumerate(42)
---
---
1 0 StrictModuleUnhandledException(TypeError)
---
test_key_error
---
x = 'abc'
d = {}
try:
    d['not present']
except KeyError:
    x = 42
---
x
---
---
test_object_init
---

x = object()
y = x.__init__()
---
y
---
---
test_object_init_arg
---

x = object()
y = x.__init__(1)
---
---
3 4 StrictModuleUnhandledException(TypeError)
---
test_object_init_kwarg
---

x = object()
y = x.__init__(x=1)
---
---
3 4 StrictModuleUnhandledException(TypeError)
---
test_object_hash_exist
---
o = object()
h = o.__hash__
h()
---
---
---
test_yield_unsupported
---
def coroutine_func():
    x = 1
    yield
    x = 2
x = coroutine_func()
x.__next__()
---
---
6 0 CoroutineFunctionNotSupportedException coroutine_func
---
test_yield_from_unsupported
---
def coroutine_func():
    x = 1
    yield
    x = 2

def coroutine_func_2():
    yield from coroutine_func()

x = coroutine_func_2()
x.__next__()
---
---
10 0 CoroutineFunctionNotSupportedException coroutine_func_2
---
test_async_call
---
async def f(l):
    l[0] = 1
l = [0]
f(l)
---
---
---
test_method_attr
---
class C:
    def f(self):
        pass
C.f.foo = 42

inst = C()
x = inst.f.foo
---
x
---
---
test_classmethod_subclass
---

class mycls(classmethod):
    pass

class D:
    @mycls
    def f(self):
        pass

x = type(D.__dict__['f']).__name__
---
x
---
---
test_staticmethod_subclass
---

class mycls(staticmethod):
    pass

class D:
    @mycls
    def f(self):
        pass

x = type(D.f).__name__
---
x
---
---
test_descriptor_get
---
class C:
    def __get__(self, inst, ctx):
        if inst is not None:
            return inst.value, ctx.__name__, 42
        return None, ctx.__name__, 100

class D:
    def __init__(self):
        self.value = 'abc'
    desc = C()

abc, name, const = D().desc
none, name2, const2 = D.desc
---
abc name const none name2 const2
---
---
test_function_defaults
---
def f(a, b, *, c):
    pass

def g(a, b=1, c=2):
    pass

def h(a, b=1, *, c=2):
    pass

def i(a, *args, c):
    pass

def j(a, *args, c=2):
    pass

d1 = f.__kwdefaults__
d2 = g.__kwdefaults__
d3 = h.__kwdefaults__
d4 = i.__kwdefaults__
d5 = j.__kwdefaults__
d6 = f.__defaults__
d7 = g.__defaults__
d8 = h.__defaults__
d9 = i.__defaults__
d0 = j.__defaults__
---
d0 d1 d2 d3 d4 d5 d6 d7 d8 d9
---
---
test_map_list
---
l = [1 ,2, 3]
def f(v):
    return v + 1
i = map(f, l)
a = next(i)
b = next(i)
c = next(i)
---
a b c
---
---
test_map_list_stop
---
l = [1 ,2, 3]
def f(v):
    return v + 1
i = map(f, l)
a = next(i)
b = next(i)
c = next(i)
d = next(i)
---
---
8 4 StrictModuleUnhandledException(StopIteration)
---
test_iter_call
---
class C:
    def __init__(self):
        self.x = 0
    def f(self):
        self.x = self.x + 1
        return self.x
obj = C()
i = iter(obj.f, 4)
a = next(i)
b = next(i)
c = next(i)
---
a b c
---
---
test_any_all
---
x = any([True, False, False])
y = all([True, False, False])
z = all([True, True, True])
w = any([False, False, False])
---
x y z w
---
---
test_empty_bytearray
---
a = bytearray()
t = type(a)
---
t
---
---
test_empty_bytearray_iter
---
a = bytearray()
i = a.__iter__()
x = i.__next__()
---
---
3 4 StrictModuleUnhandledException(StopIteration)
---
test_exec_one_scope
---
code = 'y = x'
d = {'x': 2}
exec(code, d)
y = d['y']
---
y
---
---
test_exec_two_scopes
---
code = "x = 1"
d1 = {'x': 0}
d2 = {'x': 3}
exec(code, d1, d2)
x1 = d1['x']
x2 = d2['x']
---
x1 x2
---
---
test_exec_import
---
code = 'import x'
exec(code, {})
---
---
2 0 ImportDisallowedException exec()
---
test_exec_func
---
code = """
x = 1
def f():
    return x
"""
d = {}
exec(code, d)
f = d['f']
x = f()
---
x
---
---
test_exec_func_error
---
# line and col will be inside the exec string


code = """
x = 1
def f():
    return x.y # AttributeError
"""
d = {}
exec(code, d)
f = d['f']
x = f()
---
---
12 4 StrictModuleUnhandledException(AttributeError) 4 11 StrictModuleUserException AttributeError
---
test_exec_func_error_toplevel
---
# line and col will be inside the exec string
code = """
x = 1
y = z
"""
d = {}
exec(code, d)
---
---
3 4 StrictModuleUnhandledException(NameError)
---
test_exec_class
---
code = """
class C:
    def __init__(self, y):
        self.x = y
    def plus(self, y):
        self.x = self.x + y
        return self.x
"""
d = {}
exec(code, d)
C = d['C']
c = C(10)
x = c.plus(1)
y = c.plus(11)
---
x y
---
---
test_exec_nested
---
code = """
x = 1
exec("x = 2", {})
"""
d = {}
exec(code, d)
x = d['x']
---
---
3 0 StrictModuleUnhandledException(TypeError)
---
test_object_repr
---
class C:
    pass
s = repr(C())
---
---
---
test_class_module
---
class C:
    pass
x = C.__module__
y = C().__module__
C.__module__ = 1
z = C.__module__
w = C().__module__
---
x y z w
---
---
test_object_module
---
class C:
    pass
x = C()
x.__module__ = "mod1"
y = x.__module__
C.__module__ = "mod2"
z = C.__module__
w = x.__module__
---
y z w
---
---
test_method_func
---
class C:
    def __init__(self, x):
        self.x = x
    def f(self):
        pass
f1 = C(1).f.__func__
f2 = C.f
c2 = C(2)
a1 = f1(c2)
a2 = f2(c2)
---
a1 a2
---
---
test_function_defaults_get_set
---
def f(x, y = 1):
    return x + y
d1 = f.__defaults__
a1 = f(1)
f.__defaults__ = (2,)
d2 = f.__defaults__
a2 = f(1)
f.__defaults__ = (2, 3)
d3 = f.__defaults__
a3 = f()
---
d1 a1 d1 d2 d3 a1 a2 a3
---
---
test_dict_del
---
d = {1: 2, 3: 4}
del d[1]
---
d
---
---
test_list_extend
---
l = [1, 2]
l.extend([2, 3])
---
l
---
---
test_tuple_index_method
---
l = (3, 5)
x = l.index(5)
---
x
---
---
test_str_replace
---
s = "foobar"
s1 = s.replace("o", "a")
---
s1
---
---
test_str_startswith
---
s = "foobar"
b1 = s.startswith("foo")
b2 = s.startswith("bar")
---
b1 b2
---
---
test_orig_bases
---
class C:
    def __init__(self, x):
        self.x = x
    def __mro_entries__(self, orig):
        return (C,)
CI = C(2)
class D(CI):
    pass
b1 = C in D.mro()
x = D.__orig_bases__[0].x
---
b1 x
---
---
test_str_split
---
s = "a,b,c"
l = s.split(",")
---
l
---
---
test_loose_instance_check
---
from unknown import x
loose_isinstance(x, tuple) # no error
---
---
---
test_yield_lambda
---
f = lambda: (yield)
f()
---
---
---
test_future_annotations
---
from __future__ import annotations
def f() -> unknown[int]:
    return 1
x = f()
---
x
---
---
test_future_annotations_function
---
from __future__ import annotations
def f():
    class C:
        x: unknown[int] = 1
    return C
C = f()
---
---
---
test_variable_local_annotations
---
def f():
    x : unknown() = 1
    return x
x = f()
---
x
---
---
test_range_loop
---
for i in range(10):
    pass
---
i
---
---
test_custom_iter
---
class Iterable:
    def __iter__(self):
        return Iterator()

class Iterator:
    def __init__(self):
        self.i = 0
    def __next__(self):
        if self.i == 0:
            self.i = self.i + 1
            return 42
        raise StopIteration()

l = list(Iterable())
---
l
---
---
test_generator_iter
---
def gen_f():
    for x in [1, 2, 3]:
        yield x

z = 0
for y in gen_f():
    z = y
---
---
6 0 CoroutineFunctionNotSupportedException gen_f
---
test_known_unknown_obj_no_usage @disabled
---
obj = _known_unknown_obj("foo")
class C:
    x = obj
---
---
---
test_known_unknown_obj_usage @disabled
---
obj = _known_unknown_obj("foo")
class C:
    x = obj
    def __init__(self):
        self.y = self.x.attr
c = C()
---
---
UnsafeCallException
---
test_known_unknown_callable_usage @disabled
---
obj = _known_unknown_callable("thread.lock")
class C:
    x = obj.acquire()
---
---
UnknownValueAttributeException
---
test_new_return_different_typed_instance
---
class C:
    def __new__(cls, name, *args, **kwargs):
        return D

    def __init__(self, x):
        raise Exception("should not be called")

class D:
    pass

c = C("D")
success = c is D
---
success
---
---
test_thrift_enum @disabled
---
from thrift.py3.types import Enum
class C(Enum):
    __doc__ = "1, 2, 3, "
    a: C = ...
    b: C = ...
    c: C = ...
a = int(C.a)
b = int(C.b)
c = int(C.c)
sa = str(C.a)
sb = str(C.b)
sc = str(C.c)
---
a b c sa sb sc
---
---
test_typing_TYPE_CHECKING
---
from typing import TYPE_CHECKING
x = 1
if TYPE_CHECKING:
    x = 2
---
x
---
---
test_builtin_TYPE_CHECKING @disabled
---
x = 1
if TYPE_CHECKING:
    x = 2
---
---
---
test_print
---
print(2)
print("abc", flush=True)
print(2, 3, "abc", sep = ' ', end = '')
---
---
---
test_int_ops_0
---
x = 42 + 3
---
x
---
---
test_int_ops_1
---
x = 42 - 3
---
x
---
---
test_int_ops_2
---
x = 42 * 3
---
x
---
---
test_int_ops_3
---
x = 42 / 3
---
x
---
---
test_int_ops_4
---
x = 42 << 3
---
x
---
---
test_int_ops_5
---
x = 42 >> 3
---
x
---
---
test_int_ops_6
---
x = 42 | 3
---
x
---
---
test_int_ops_7
---
x = 42 & 3
---
x
---
---
test_int_ops_8
---
x = 42 ^ 3
---
x
---
---
test_int_ops_9
---
x = 42 % 3
---
x
---
---
test_int_ops_10
---
x = 42 ** 3
---
x
---
---
test_int_ops_11
---
x = 42 // 3
---
x
---
---
test_int_unary_ops_0
---
x = +42
---
x
---
---
test_int_unary_ops_1
---
x = -42
---
x
---
---
test_int_unary_ops_2
---
x = ~42
---
x
---
---
test_big_integers
---
x1 = 9223372036854775807
x2 = 9223372036854775808
x3 = -9223372036854775807
x4 = -9223372036854775808
x5 = -9223372036854775809
x6 = 1119223372036854775809
x7 = -1119223372036854775809
x8 = x1 + x2
x9 = x1 - x7
x10 = x1 & 111
x11 = x6 * x2
x12 = x7 > 1.111
x13 = x3 > 1.111
x14 = x6 - x7
---
x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14
---
---
test_numeric_compare_eq_ne
---
x1 = 1 == 1
x2 = 1 != 1
x3 = 1.0 == 1
x4 = 1.0 != 1
x5 = 1 == 1.0
x6 = 1 != 1.0
x7 = 1.0 == 1.0
x8 = 1.0 != 1.0
---
x1 x2 x3 x4 x5 x6 x7 x8
---
---
test_numeric_compare_int_int
---
x1 = 1 > 2
x2 = 1 >= 3
x3 = 1 < 4
x4 = 1 <= 5
---
x1 x2 x3 x4
---
---
test_numeric_compare_int_float
---
x1 = 1 > 1.1
x2 = 1 >= 1.1
x3 = 1 < 1.1
x4 = 1 <= 1.1
---
x1 x2 x3 x4
---
---
test_numeric_compare_float_int
---
x1 = 1.1 > 1
x2 = 1.1 >= 1
x3 = 1.1 < 1
x4 = 1.1 <= 1
---
x1 x2 x3 x4
---
---
test_numeric_compare_float_float
---
x1 = 1.0 > 1.1
x2 = 1.0 >= 1.1
x3 = 1.0 < 1.1
x4 = 1.0 <= 1.1
---
x1 x2 x3 x4
---
---
test_float_ops_0
---
x = 42.0 + 3.0
---
x
---
---
test_float_ops_1
---
x = 42.0 - 3.0
---
x
---
---
test_float_ops_2
---
x = 42.0 * 3.0
---
x
---
---
test_float_ops_3
---
x = 42.0 / 3.0
---
x
---
---
test_float_ops_4
---
x = 42.0 % 3.0
---
x
---
---
test_float_ops_5
---
x = 42.0 ** 3.0
---
x
---
---
test_float_ops_6
---
x = 42.0 // 3.0
---
x
---
---
test_float_error_ops_0
---
x = 42.0 << 3.0
---
---
1 4 StrictModuleUnhandledException(TypeError)
---
test_float_error_ops_1
---
x = 42.0 >> 3.0
---
---
1 4 StrictModuleUnhandledException(TypeError)
---
test_float_error_ops_2
---
x = 42.0 | 3.0
---
---
1 4 StrictModuleUnhandledException(TypeError)
---
test_float_error_ops_3
---
x = 42.0 & 3.0
---
---
1 4 StrictModuleUnhandledException(TypeError)
---
test_float_error_ops_4
---
x = 42.0 ^ 3.0
---
---
1 4 StrictModuleUnhandledException(TypeError)
---
test_float_unary_ops_0
---
x = +42.0
---
x
---
---
test_float_unary_ops_1
---
x = -42.0
---
x
---
---
test_complex_ops_0 @disabled
---
x = (42.0+0j) + (3.0+0j)
---
x
---
---
test_complex_ops_1 @disabled
---
x = (42.0+0j) - (3.0+0j)
---
x
---
---
test_complex_ops_2 @disabled
---
x = (42.0+0j) * (3.0+0j)
---
x
---
---
test_complex_ops_3 @disabled
---
x = (42.0+0j) / (3.0+0j)
---
x
---
---
test_complex_ops_4 @disabled
---
x = (42.0+0j) ** (3.0+0j)
---
x
---
---
test_complex_unary_ops_0 @disabled
---
x = +42j
---
x
---
---
test_complex_unary_ops_1 @disabled
---
x = -42j
---
x
---
---
test_complex_error_ops_0 @disabled
---
x = (42.0+0j) << (3.0+0j)
---
---
StrictModuleTypeError
---
test_complex_error_ops_1 @disabled
---
x = (42.0+0j) >> (3.0+0j)
---
---
StrictModuleTypeError
---
test_complex_error_ops_2 @disabled
---
x = (42.0+0j) | (3.0+0j)
---
---
StrictModuleTypeError
---
test_complex_error_ops_3 @disabled
---
x = (42.0+0j) & (3.0+0j)
---
---
StrictModuleTypeError
---
test_complex_error_ops_4 @disabled
---
x = (42.0+0j) ^ (3.0+0j)
---
---
StrictModuleTypeError
---
test_complex_error_ops_5 @disabled
---
x = (42.0+0j) // (3.0+0j)
---
---
StrictModuleTypeError
---
test_complex_error_ops_6 @disabled
---
x = (42.0+0j) % (3.0+0j)
---
---
StrictModuleTypeError
---
test_str_index_0
---
x = "abc"[0]
---
x
---
---
test_str_index_1
---
x = "abc"[-1]
---
x
---
---
test_str_index_2
---
x = "abc"[1:2]
---
x
---
---
test_str_index_3
---
x = "abc"[0:-1]
---
x
---
---
test_str_index_4
---
x = "abc"[::-1]
---
x
---
---
test_str_index_5
---
x = ""[1:2]
---
x
---
---
test_str_isidentifier_0
---
x = "abc".isidentifier()
---
x
---
---
test_str_isidentifier_1
---
x = "def".isidentifier()
---
x
---
---
test_str_isidentifier_2
---
x = "01".isidentifier()
---
x
---
---
test_str_isidentifier_3
---
x = "abc def".isidentifier()
---
x
---
---
test_func_code_0
---
def f(b, a): d = 1; c = 2
code = f.__code__
argcount = code.co_argcount
varnames = code.co_varnames
kwonly = code.co_kwonlyargcount
name = code.co_name
flags = code.co_flags
---
argcount varnames kwonly name flags
---
---
test_func_code_1
---
def f(*, x = 1): pass
code = f.__code__
argcount = code.co_argcount
varnames = code.co_varnames
kwonly = code.co_kwonlyargcount
name = code.co_name
flags = code.co_flags
---
argcount varnames kwonly name flags
---
---
test_func_code_2
---
def f(*args): pass
code = f.__code__
argcount = code.co_argcount
varnames = code.co_varnames
kwonly = code.co_kwonlyargcount
name = code.co_name
flags = code.co_flags
---
argcount varnames kwonly name flags
---
---
test_func_code_3
---
def f(**kwargs): pass
code = f.__code__
argcount = code.co_argcount
varnames = code.co_varnames
kwonly = code.co_kwonlyargcount
name = code.co_name
flags = code.co_flags
---
argcount varnames kwonly name flags
---
---
test_func_code_4
---
def f(*args, **kwargs): pass
code = f.__code__
argcount = code.co_argcount
varnames = code.co_varnames
kwonly = code.co_kwonlyargcount
name = code.co_name
flags = code.co_flags
---
argcount varnames kwonly name flags
---
---
test_func_code_5
---
def f(): yield 42
code = f.__code__
argcount = code.co_argcount
varnames = code.co_varnames
kwonly = code.co_kwonlyargcount
name = code.co_name
flags = code.co_flags
---
argcount varnames kwonly name flags
---
---
test_func_code_6
---
def f(): lambda: (yield 42)
code = f.__code__
argcount = code.co_argcount
varnames = code.co_varnames
kwonly = code.co_kwonlyargcount
name = code.co_name
flags = code.co_flags
---
argcount varnames kwonly name flags
---
---
test_func_code_7
---
def f(): lambda: (yield 42)
code = f.__code__
argcount = code.co_argcount
varnames = code.co_varnames
kwonly = code.co_kwonlyargcount
name = code.co_name
flags = code.co_flags
---
argcount varnames kwonly name flags
---
---
test_func_code_8
---
async def f(): pass
code = f.__code__
argcount = code.co_argcount
varnames = code.co_varnames
kwonly = code.co_kwonlyargcount
name = code.co_name
flags = code.co_flags
---
argcount varnames kwonly name flags
---
---
test_func_code_9
---
async def f(): await foo
code = f.__code__
argcount = code.co_argcount
varnames = code.co_varnames
kwonly = code.co_kwonlyargcount
name = code.co_name
flags = code.co_flags
---
argcount varnames kwonly name flags
---
---
test_func_code_10
---
async def f(): yield 42
code = f.__code__
argcount = code.co_argcount
varnames = code.co_varnames
kwonly = code.co_kwonlyargcount
name = code.co_name
flags = code.co_flags
---
argcount varnames kwonly name flags
---
---
test_func_code_11
---
def f():
    def f():        yield 42
code = f.__code__
argcount = code.co_argcount
varnames = code.co_varnames
kwonly = code.co_kwonlyargcount
name = code.co_name
flags = code.co_flags
---
argcount varnames kwonly name flags
---
---
test_func_code_12
---
def f():
    async def f():        yield 42
code = f.__code__
argcount = code.co_argcount
varnames = code.co_varnames
kwonly = code.co_kwonlyargcount
name = code.co_name
flags = code.co_flags
---
argcount varnames kwonly name flags
---
---
test_func_code_13
---
def f():
    class C:        pass
code = f.__code__
argcount = code.co_argcount
varnames = code.co_varnames
kwonly = code.co_kwonlyargcount
name = code.co_name
flags = code.co_flags
---
argcount varnames kwonly name flags
---
---
test_func_code_14
---
def f():
    x = 2
    def g():        return x
code = f.__code__
argcount = code.co_argcount
varnames = code.co_varnames
kwonly = code.co_kwonlyargcount
name = code.co_name
flags = code.co_flags
---
argcount varnames kwonly name flags
---
---
test_func_code_15
---
def f(x):
    def g():        return x
code = f.__code__
argcount = code.co_argcount
varnames = code.co_varnames
kwonly = code.co_kwonlyargcount
name = code.co_name
flags = code.co_flags
---
argcount varnames kwonly name flags
---
---
test_func_code_16
---
def f(x):
    x = 2
    def g():
        nonlocal x
        x = 3
code = f.__code__
argcount = code.co_argcount
varnames = code.co_varnames
kwonly = code.co_kwonlyargcount
name = code.co_name
flags = code.co_flags
---
argcount varnames kwonly name flags
---
---
test_set_binop_0
---
l = set((1, 2))
r = set((3, 4))
a = l & r
o = l | r
x = l ^ r
---
l r a o x
---
---
test_set_binop_1
---
l = set((1, 2))
r = set((1, 2))
a = l & r
o = l | r
x = l ^ r
---
l r a o x
---
---
test_set_binop_2
---
l = set((1, 2))
r = set((2, 3))
a = l & r
o = l | r
x = l ^ r
---
l r a o x
---
---
test_frozenset_binop_0
---
l = frozenset((1, 2))
r = frozenset((3, 4))
a = l & r
o = l | r
x = l ^ r
---
l r a o x
---
---
test_frozenset_binop_1
---
l = frozenset((1, 2))
r = frozenset((1, 2))
a = l & r
o = l | r
x = l ^ r
---
l r a o x
---
---
test_frozenset_binop_2
---
l = frozenset((1, 2))
r = frozenset((2, 3))
a = l & r
o = l | r
x = l ^ r
---
l r a o x
---
---
test_iterator_0
---
l = [1, 2, 3]
i = l.__iter__()
a = i.__next__()
b = i.__next__()
c = i.__next__()
---
a b c
---
---
test_iterator_1
---
l = (1, 2, 3)
i = l.__iter__()
a = i.__next__()
b = i.__next__()
c = i.__next__()
---
a b c
---
---
test_iterator_2
---
l = {1, 2, 3}
i = l.__iter__()
a = i.__next__()
b = i.__next__()
c = i.__next__()
d = {a, b, c}
---
d
---
---
test_iterator_3
---
l = (i for i in [1, 2, 3])
i = l.__iter__()
a = i.__next__()
b = i.__next__()
c = i.__next__()
d = {a, b, c}
---
d
---
---
test_iterator_4
---
l = {1:3, 2:4, 3:5}.keys()
i = l.__iter__()
a = i.__next__()
b = i.__next__()
c = i.__next__()
s = {a, b, c}
---
s
---
---
test_iterator_5
---
l = {3:1, 4:2, 5:3}.values()
i = l.__iter__()
a = i.__next__()
b = i.__next__()
c = i.__next__()
s = {a, b, c}
---
s
---
---
test_iterator_6
---
l = {1:3, 2:4, 3:5}.items()
i = l.__iter__()
a = i.__next__()
b = i.__next__()
c = i.__next__()
s = {a, b, c}
---
s
---
---
test_iterator_7
---
l = 'abc'
i = l.__iter__()
a = i.__next__()
b = i.__next__()
c = i.__next__()
---
a b c
---
---
test_iterator_8
---
l = b'abc'
i = l.__iter__()
a = i.__next__()
b = i.__next__()
c = i.__next__()
---
a b c
---
---
test_iterator_9
---
l = range(3)
i = l.__iter__()
a = i.__next__()
b = i.__next__()
c = i.__next__()
---
a b c
---
---
test_iterator_10
---
l = zip([1, 2, 3], [4, 5, 6])
i = l.__iter__()
a = i.__next__()
b = i.__next__()
c = i.__next__()
---
a b c
---
---
test_iterator_stop_0
---
l = [1, 2, 3]
i = l.__iter__()
a = i.__next__()
b = i.__next__()
c = i.__next__()
i.__next__()
---
---
6 0 StrictModuleUnhandledException(StopIteration)
---
test_iterator_stop_1
---
l = (1, 2, 3)
i = l.__iter__()
a = i.__next__()
b = i.__next__()
c = i.__next__()
i.__next__()
---
---
6 0 StrictModuleUnhandledException(StopIteration)
---
test_iterator_stop_2
---
l = {1, 2, 3}
i = l.__iter__()
a = i.__next__()
b = i.__next__()
c = i.__next__()
i.__next__()
---
---
6 0 StrictModuleUnhandledException(StopIteration)
---
test_iterator_stop_3
---
l = (i for i in [1, 2, 3])
i = l.__iter__()
a = i.__next__()
b = i.__next__()
c = i.__next__()
i.__next__()
---
---
6 0 StrictModuleUnhandledException(StopIteration)
---
test_iterator_stop_4
---
l = {1:3, 2:4, 3:5}.keys()
i = l.__iter__()
a = i.__next__()
b = i.__next__()
c = i.__next__()
i.__next__()
---
---
6 0 StrictModuleUnhandledException(StopIteration)
---
test_iterator_stop_5
---
l = {3:1, 4:2, 5:3}.values()
i = l.__iter__()
a = i.__next__()
b = i.__next__()
c = i.__next__()
i.__next__()
---
---
6 0 StrictModuleUnhandledException(StopIteration)
---
test_iterator_stop_6
---
l = {1:3, 2:4, 3:5}.items()
i = l.__iter__()
a = i.__next__()
b = i.__next__()
c = i.__next__()
i.__next__()
---
---
6 0 StrictModuleUnhandledException(StopIteration)
---
test_iterator_stop_7
---
l = 'abc'
i = l.__iter__()
a = i.__next__()
b = i.__next__()
c = i.__next__()
i.__next__()
---
---
6 0 StrictModuleUnhandledException(StopIteration)
---
test_iterator_stop_8
---
l = b'abc'
i = l.__iter__()
a = i.__next__()
b = i.__next__()
c = i.__next__()
i.__next__()
---
---
6 0 StrictModuleUnhandledException(StopIteration)
---
test_iterator_stop_9
---
l = range(3)
i = l.__iter__()
a = i.__next__()
b = i.__next__()
c = i.__next__()
i.__next__()
---
---
6 0 StrictModuleUnhandledException(StopIteration)
---
test_iterator_stop_10
---
l = zip([1, 2, 3], [4, 5, 6])
i = l.__iter__()
a = i.__next__()
b = i.__next__()
c = i.__next__()
i.__next__()
---
---
6 0 StrictModuleUnhandledException(StopIteration)
---
test_iter_next_0
---
l = [1, 2, 3]
i = iter(l)
a = next(i)
b = next(i)
c = next(i)
---
a b c
---
---
test_iter_next_1
---
l = (1, 2, 3)
i = iter(l)
a = next(i)
b = next(i)
c = next(i)
---
a b c
---
---
test_iter_next_2
---
l = {1, 2, 3}
i = iter(l)
a = next(i)
b = next(i)
c = next(i)
x = {a, b, c}
---
x
---
---
test_iter_next_3
---
l = (i for i in [1, 2, 3])
i = iter(l)
a = next(i)
b = next(i)
c = next(i)
---
a b c
---
---
test_iter_next_4
---
l = {1:3, 2:4, 3:5}.keys()
i = iter(l)
a = next(i)
b = next(i)
c = next(i)
x = {a, b, c}
---
x
---
---
test_iter_next_5
---
l = {3:1, 4:2, 5:3}.values()
i = iter(l)
a = next(i)
b = next(i)
c = next(i)
x = {a, b, c}
---
x
---
---
test_iter_next_6
---
l = {1:3, 2:4, 3:5}.items()
i = iter(l)
a = next(i)
b = next(i)
c = next(i)
x = {a, b, c}
---
x
---
---
test_iter_next_7
---
l = 'abc'
i = iter(l)
a = next(i)
b = next(i)
c = next(i)
x = {a, b, c}
---
x
---
---
test_iter_next_8
---
l = b'abc'
i = iter(l)
a = next(i)
b = next(i)
c = next(i)
---
a b c
---
---
test_iter_next_9
---
l = range(3)
i = iter(l)
a = next(i)
b = next(i)
c = next(i)
---
a b c
---
---
test_iter_next_10
---
l = zip([1, 2, 3], [4, 5, 6])
i = iter(l)
a = next(i)
b = next(i)
c = next(i)
---
a b c
---
---
test_iter_next_stop_0
---
l = [1, 2, 3]
i = iter(l)
a = next(i)
b = next(i)
c = next(i)
next(i)
---
---
6 0 StrictModuleUnhandledException(StopIteration)
---
test_iter_next_stop_1
---
l = (1, 2, 3)
i = iter(l)
a = next(i)
b = next(i)
c = next(i)
next(i)
---
---
6 0 StrictModuleUnhandledException(StopIteration)
---
test_iter_next_stop_2
---
l = {1, 2, 3}
i = iter(l)
a = next(i)
b = next(i)
c = next(i)
next(i)
---
---
6 0 StrictModuleUnhandledException(StopIteration)
---
test_iter_next_stop_3
---
l = (i for i in [1, 2, 3])
i = iter(l)
a = next(i)
b = next(i)
c = next(i)
next(i)
---
---
6 0 StrictModuleUnhandledException(StopIteration)
---
test_iter_next_stop_4
---
l = {1:3, 2:4, 3:5}.keys()
i = iter(l)
a = next(i)
b = next(i)
c = next(i)
next(i)
---
---
6 0 StrictModuleUnhandledException(StopIteration)
---
test_iter_next_stop_5
---
l = {3:1, 4:2, 5:3}.values()
i = iter(l)
a = next(i)
b = next(i)
c = next(i)
next(i)
---
---
6 0 StrictModuleUnhandledException(StopIteration)
---
test_iter_next_stop_6
---
l = {1:3, 2:4, 3:5}.items()
i = iter(l)
a = next(i)
b = next(i)
c = next(i)
next(i)
---
---
6 0 StrictModuleUnhandledException(StopIteration)
---
test_iter_next_stop_7
---
l = 'abc'
i = iter(l)
a = next(i)
b = next(i)
c = next(i)
next(i)
---
---
6 0 StrictModuleUnhandledException(StopIteration)
---
test_iter_next_stop_8
---
l = b'abc'
i = iter(l)
a = next(i)
b = next(i)
c = next(i)
next(i)
---
---
6 0 StrictModuleUnhandledException(StopIteration)
---
test_iter_next_stop_9
---
l = range(3)
i = iter(l)
a = next(i)
b = next(i)
c = next(i)
next(i)
---
---
6 0 StrictModuleUnhandledException(StopIteration)
---
test_iter_next_stop_10
---
l = zip([1, 2, 3], [4, 5, 6])
i = iter(l)
a = next(i)
b = next(i)
c = next(i)
next(i)
---
---
6 0 StrictModuleUnhandledException(StopIteration)
---
test_reversed_next_0
---
l = [1, 2, 3]
i = reversed(l)
a = next(i)
b = next(i)
c = next(i)
---
a b c
---
---
test_reversed_stop_0
---
l = [1, 2, 3]
i = reversed(l)
a = next(i)
b = next(i)
c = next(i)
next(i)
---
---
6 0 StrictModuleUnhandledException(StopIteration)
---
test_dunder_repr_0
---
x = (None).__repr__()
y = repr(None)
z = str(None)
---
x y z
---
---
test_dunder_repr_1
---
x = (True).__repr__()
y = repr(True)
z = str(True)
---
x y z
---
---
test_dunder_repr_2
---
x = (1).__repr__()
y = repr(1)
z = str(1)
---
x y z
---
---
test_dunder_repr_3
---
x = (1.5).__repr__()
y = repr(1.5)
z = str(1.5)
---
x y z
---
---
test_dunder_repr_4 @disabled
---
x = (2j).__repr__()
y = repr(2j)
z = str(2j)
---
x y z
---
---
test_dunder_repr_5
---
x = ((1, 2)).__repr__()
y = repr((1, 2))
z = str((1, 2))
---
x y z
---
---
test_dunder_repr_6
---
x = ([1, 2]).__repr__()
y = repr([1, 2])
z = str([1, 2])
---
x y z
---
---
test_dunder_repr_7
---
x = ({1, 2}).__repr__()
y = repr({1, 2})
z = str({1, 2})
---
x y z
---
---
test_dunder_repr_8
---
x = ({1: 2}).__repr__()
y = repr({1: 2})
z = str({1: 2})
---
x y z
---
---
test_dunder_repr_9
---
x = ('abc').__repr__()
y = repr('abc')
z = str('abc')
---
x y z
---
---
test_native_generic_alias
---
t = list[int]
a = t.__origin__
---
a
---
---
test_native_generic_alias_args
---
from typing import TypeVar
T = TypeVar("T")
t = list[T]
t1 = t[int]
a = t1.__origin__
b = t1.__args__
---
a b
---
---
test_union_builtin_syntax_0
---
t = int | str
is_int_instance = isinstance(1, t)
is_str_instance = isinstance('a', t)
is_None_instance = isinstance(None, t)
has_int = issubclass(int, t)
has_str = issubclass(str, t)
arg_size = len(t.__args__)
---
is_int_instance is_str_instance is_None_instance has_int has_str arg_size
---
---
test_union_builtin_syntax_1
---
t = int | str | float
is_int_instance = isinstance(1, t)
is_str_instance = isinstance('a', t)
is_None_instance = isinstance(None, t)
has_int = issubclass(int, t)
has_str = issubclass(str, t)
arg_size = len(t.__args__)
---
is_int_instance is_str_instance is_None_instance has_int has_str arg_size
---
---
test_union_builtin_syntax_2
---
t = int | (str | float)
is_int_instance = isinstance(1, t)
is_str_instance = isinstance('a', t)
is_None_instance = isinstance(None, t)
has_int = issubclass(int, t)
has_str = issubclass(str, t)
arg_size = len(t.__args__)
---
is_int_instance is_str_instance is_None_instance has_int has_str arg_size
---
---
test_union_builtin_syntax_3
---
t = int | None
is_int_instance = isinstance(1, t)
is_str_instance = isinstance('a', t)
is_None_instance = isinstance(None, t)
has_int = issubclass(int, t)
has_str = issubclass(str, t)
arg_size = len(t.__args__)
---
is_int_instance is_str_instance is_None_instance has_int has_str arg_size
---
---
test_union_builtin_syntax_4
---
t = None | int
is_int_instance = isinstance(1, t)
is_str_instance = isinstance('a', t)
is_None_instance = isinstance(None, t)
has_int = issubclass(int, t)
has_str = issubclass(str, t)
arg_size = len(t.__args__)
---
is_int_instance is_str_instance is_None_instance has_int has_str arg_size
---
---
test_union_builtin_syntax_5
---
t = str | None
is_int_instance = isinstance(1, t)
is_str_instance = isinstance('a', t)
is_None_instance = isinstance(None, t)
has_int = issubclass(int, t)
has_str = issubclass(str, t)
arg_size = len(t.__args__)
---
is_int_instance is_str_instance is_None_instance has_int has_str arg_size
---
---
test_union_builtin_syntax_6
---
t = None | str
is_int_instance = isinstance(1, t)
is_str_instance = isinstance('a', t)
is_None_instance = isinstance(None, t)
has_int = issubclass(int, t)
has_str = issubclass(str, t)
arg_size = len(t.__args__)
---
is_int_instance is_str_instance is_None_instance has_int has_str arg_size
---
---
test_union_builtin_syntax_7
---
t = int | int
is_int_instance = isinstance(1, t)
is_str_instance = isinstance('a', t)
is_None_instance = isinstance(None, t)
has_int = issubclass(int, t)
has_str = issubclass(str, t)
---
t:int is_int_instance is_str_instance is_None_instance has_int has_str
---
---
test_union_builtin_syntax_8
---
t = str | str
is_int_instance = isinstance(1, t)
is_str_instance = isinstance('a', t)
is_None_instance = isinstance(None, t)
has_int = issubclass(int, t)
has_str = issubclass(str, t)
---
t:str is_int_instance is_str_instance is_None_instance has_int has_str
---
---
test_union_builtin_with_typing_0
---
from typing import Union, List
from types import UnionType
t = int | str
is_types_union = isinstance(t, UnionType)
arg_size = len(t.__args__)
---
is_types_union arg_size
---
---
test_union_builtin_with_typing_1
---
from typing import Union, List
from types import UnionType
t = int | List[str]
is_types_union = isinstance(t, UnionType)
arg_size = len(t.__args__)
---
is_types_union arg_size
---
---
test_union_builtin_with_typing_2
---
from typing import Union, List
from types import UnionType
t = List[int] | str
is_types_union = isinstance(t, UnionType)
arg_size = len(t.__args__)
---
is_types_union arg_size
---
---
test_union_builtin_with_typing_3
---
from typing import Union, List
from types import UnionType
t = Union[int, str] | float
is_types_union = isinstance(t, UnionType)
arg_size = len(t.__args__)
---
is_types_union arg_size
---
---
test_union_builtin_with_typing_4
---
from typing import Union, List
from types import UnionType
t = float | Union[int, str]
is_types_union = isinstance(t, UnionType)
arg_size = len(t.__args__)
---
is_types_union arg_size
---
---
test_union_builtin_with_typing_5
---
from typing import Union, List
from types import UnionType
t = float | Union[int, str] | float
is_types_union = isinstance(t, UnionType)
arg_size = len(t.__args__)
---
is_types_union arg_size
---
---
test_union_builtin_with_typing_6
---
from typing import Union, List
from types import UnionType
t = Union[str, int] | None
is_types_union = isinstance(t, UnionType)
arg_size = len(t.__args__)
---
is_types_union arg_size
---
---
test_union_builtin_with_typing_7
---
from typing import Union, List
from types import UnionType
t = None | Union[str, int]
is_types_union = isinstance(t, UnionType)
arg_size = len(t.__args__)
---
is_types_union arg_size
---
---
test_union_builtin_with_typing_8
---
from typing import Union, List
from types import UnionType
t = Union[int, None] | str
is_types_union = isinstance(t, UnionType)
arg_size = len(t.__args__)
---
is_types_union arg_size
---
---
test_union_builtin_with_typing_9
---
from typing import Union, List
from types import UnionType
t = None | Union[str, None]
is_types_union = isinstance(t, UnionType)
arg_size = len(t.__args__)
---
is_types_union arg_size
---
---
test_union_builtin_with_typing_10 @disabled
---
from typing import Union, List
from types import UnionType
t = Union[int, int] | int
is_types_union = isinstance(t, UnionType)
---
is_types_union
---
---
test_import_usage
---
import a
y = a.b
---
---
2 4 UnknownValueAttributeException <imported module a> b
---
test_import_assign_usage
---
import a
b = a
c = b
d = c.x
---
---
4 4 UnknownValueAttributeException <imported module a> x
---
test_from_import_assign_usage
---
from m import a
b = a
c = b
d = c.x
---
---
4 4 UnknownValueAttributeException <a imported from m> x
---
test_from_import_alias_assign_usage
---
from m import foo as a
b = a
c = b
d = c.x
---
---
4 4 UnknownValueAttributeException <foo imported from m as a> x
---
test_relative_import_usage
---
from .. import foo as a
b = a.x
---
---
2 4 UnknownValueAttributeException <foo imported from .. as a> x
---
test_import_aug_assign_usage
---
import m as a
a += 1
---
---
2 0 UnknownValueBinaryOpException <imported module m as a> + 1
---
test_import_ann_assign_usage
---
import m as a
b: int = a
c = b.x
---
---
3 4 UnknownValueAttributeException <imported module m as a> x
---
test_import_ann_no_assign_usage
---
import m as a
b: a.C
---
---
2 3 UnknownValueAttributeException <imported module m as a> C
---
test_import_assign_raise
---
import m as a
b = a
raise a.err
---
---
3 6 UnknownValueAttributeException <imported module m as a> err
3 0 StrictModuleUnhandledException(<imported module m as a>.err)
---
test_import_raise_ok
---
import m
try:
    a = 1
except Exception as m:
    k = m.msg
---
---
---
test_import_try_usage
---
import m as a
try:
    b = a.x
except:
    pass
---
---
3 8 UnknownValueAttributeException <imported module m as a> x
---
test_import_except_usage
---
import m as a
try:
    b = 1
    raise Exception()
except Exception as e:
    b = a.x
---
---
6 8 UnknownValueAttributeException <imported module m as a> x
---
test_import_else_usage
---
import m as a
try:
    b = 1
except Exception as e:
    b = 2
else:
    b = a.x
---
---
7 8 UnknownValueAttributeException <imported module m as a> x
---
test_import_finally_usage
---
import m as a
try:
    b = 1
finally:
    b = a.x
---
---
5 8 UnknownValueAttributeException <imported module m as a> x
---
test_import_list_usage
---
import m as a
l = [1, 2, a.x]
---
---
2 11 UnknownValueAttributeException <imported module m as a> x
---
test_import_list_assign_usage_ok
---
import m as a
l = [1, a]
b = l.append
---
---
---
test_import_list_matched_assign_usage
---
import m as a
[x, y] = [1, a]
b = x.__bool__ # ok
c = y.v # not ok
---
---
4 4 UnknownValueAttributeException <imported module m as a> v
---
test_import_list_unpack_assign_usage
---
import m as a
[x, y] = a, 'foo'
b = x.v
---
---
3 4 UnknownValueAttributeException <imported module m as a> v
---
test_import_list_unpack_bad_rhs
---
import m as a
[x, y] = a
---
---
2 0 UnknownValueNotIterableException <imported module m as a>
2 0 FailedToUnpackException 2
---
test_import_list_index_usage
---
import m as a
l = [a, 1]
b = l[0].x
---
---
3 4 UnknownValueAttributeException <imported module m as a> x
---
test_import_list_assign_ok
---
import m as a
l = [1, 2]
l[0] = a
b = l.append # ok
---
---
---
test_import_list_assign_index_usage
---
import m as a
l = [1, 2]
l[0] = a
b = l[0].x
---
---
4 4 UnknownValueAttributeException <imported module m as a> x
---
test_import_list_multilevel_index_usage
---
import m as a
l = [1, [3, 4, a]]
b = l[0].__bool__ # ok
c = l[1][2].x
---
---
4 4 UnknownValueAttributeException <imported module m as a> x
---
test_import_list_assign_usage
---
import m as a
l = [1, a]
l2 = [1, 2, 3]
l2[1] = [l]
d = l2[1][0][1]
c = d.x
---
---
6 4 UnknownValueAttributeException <imported module m as a> x
---
test_import_list_conditional_assign_usage
---
import m as a
l1 = [1, 2]
if 1 < 0:
    l1[0] = a
else:
    l1[0] = 2
b = l1[0].__bool__
---
---
---
test_import_attr_assign_usage
---
import m as a
def b(): pass
b.x = a
c = b.x.y
---
---
4 4 UnknownValueAttributeException <imported module m as a> y
---
test_import_attr_multi_assign_usage
---
import m as a
def b(): pass
def c(): pass
b.x = a
c.y = b
d = c.y.x.z
---
---
6 4 UnknownValueAttributeException <imported module m as a> z
---
test_import_unary_op_usage
---
import m as a
-a
---
---
2 0 UnknownValueUnaryOpException - <imported module m as a>
---
test_import_binary_op_usage
---
import m as a
a + 1
---
---
2 0 UnknownValueBinaryOpException <imported module m as a> + 1
---
test_import_bool_op_usage_1
---
import m as a
False or a
---
---
2 0 UnknownValueBoolException <imported module m as a>
---
test_import_bool_op_usage_2
---
import m as a
True and a
---
---
2 0 UnknownValueBoolException <imported module m as a>
---
test_import_compare_usage
---
import m as a
1 < a < 2
---
---
2 0 UnknownValueAttributeException <imported module m as a> __gt__
2 0 UnknownValueBoolException 1 < <imported module m as a>
---
test_import_if_exp_assign_usage
---
import m as a
b = 2 if 1 in [2] else a
b.x
---
---
3 0 UnknownValueAttributeException <imported module m as a> x
---
test_import_if_exp_assign_usage_ok
---
import m as a
b = 2 if True else a
b.__bool__
---
---
---
test_import_delete_usage
---
import m as a
del a.x
---
---
2 0 UnknownValueAttributeException <imported module m as a> x
---
test_import_pass_ok
---
import m as a
pass
---
---
---
test_import_if_condition_usage
---
import m as a
if a:
    pass
---
---
2 0 UnknownValueBoolException <imported module m as a>
---
test_import_if_clause_usage
---
import m as a
if 1 + 1 == 2:
    b = a.x
else:
    pass
---
---
3 8 UnknownValueAttributeException <imported module m as a> x
---
test_import_if_orelse_clause_usage
---
import m as a
if 1 in [2]:
    pass
else:
    b = a.x
---
---
5 8 UnknownValueAttributeException <imported module m as a> x
---
test_import_for_usage
---
import m as a
for i in a:
    b = i
---
---
2 0 UnknownValueNotIterableException <imported module m as a>
---
test_namedtuple_def_1
---
from collections import namedtuple
namedtuple("P", "x y")
---
---
---
test_import_for_statement_usage
---
import m as a
for i in [1, 2]:
    a.x
---
---
3 4 UnknownValueAttributeException <imported module m as a> x
3 4 UnknownValueAttributeException <imported module m as a> x
---
test_import_while_usage
---
import m as a
while a:
    pass
---
---
2 0 UnknownValueBoolException <imported module m as a>
---
test_namedtuple_constructor
---
from collections import namedtuple
P = namedtuple("P", "x y")
P(1, 2)
---
---
---
test_import_while_statement_usage
---
import m as a
x = 1
while x < 2:
    b = a.x
    x = x + 1
---
---
4 8 UnknownValueAttributeException <imported module m as a> x
---
test_import_with_context_usage
---
import m as a
with a:
    b = 1
---
---
2 0 UnknownValueAttributeException <imported module m as a> __enter__
2 0 UnknownValueCallException <imported module m as a>.__enter__
2 0 UnknownValueAttributeException <imported module m as a> __exit__
2 0 UnknownValueCallException <imported module m as a>.__exit__
2 0 UnknownValueBoolException <imported module m as a>.__exit__(None,None,None,)
---
test_import_with_body_usage
---
import m as a
class E:
    def __enter__(self):
        return self
    def __exit__(self, a, b, c):
        return

with E():
    a.x
---
---
9 4 UnknownValueAttributeException <imported module m as a> x
---
test_import_with_alias_usage
---
import m as a
class E:
    def __enter__(self):
        return a
    def __exit__(self, a, b, c):
        return

with E() as c:
    b = c.x
---
---
9 8 UnknownValueAttributeException <imported module m as a> x
---
test_import_comprehension_usage
---
import m as a
b = [a.x for i in [1, 2]]
---
---
2 5 UnknownValueAttributeException <imported module m as a> x
2 5 UnknownValueAttributeException <imported module m as a> x
---
test_import_comprehension_member_usage
---
import m as a
b = [i for i in [1, 2, a.x]]
---
---
2 23 UnknownValueAttributeException <imported module m as a> x
---
test_import_comprehension_transitive_usage
---
import m as a
b = [i.__bool__ for i in [1, 2, a]]
---
---
2 5 UnknownValueAttributeException <imported module m as a> __bool__
---
test_import_comprehension_shadow_ok
---
import m as a
b = [a.__bool__ for a in [1, 2, 3]]
---
---
---
test_import_comprehension_shadow_usage
---
import m as a
b = [a.__bool__ for a in [1, 2, a]]
---
---
2 5 UnknownValueAttributeException <imported module m as a> __bool__
---
test_import_comprehension_nested_usage
---
import m as a
l = [1, 2, a]
l1 = [l]
l2 = [1, 2, 3]
b = [a.__bool__ for l2 in l1 for a in l2]
---
---
5 5 UnknownValueAttributeException <imported module m as a> __bool__
---
test_import_dict_key_usage
---
import m as a
d = {1: 2, a.x: 3}
---
---
2 11 UnknownValueAttributeException <imported module m as a> x
---
test_import_dict_value_usage
---
import m as a
d = {1: 2, 3: a.x}
---
---
2 14 UnknownValueAttributeException <imported module m as a> x
---
test_import_dict_index_usage
---
import m as a
d = {1: 2, 3: a}
d[3].x
---
---
3 0 UnknownValueAttributeException <imported module m as a> x
---
test_import_dict_comprehension_key_usage
---
import m as a
l = [(a, 2)]
d = {k.x: v for k, v in l}
---
---
3 5 UnknownValueAttributeException <imported module m as a> x
---
test_import_dict_comprehension_key_usage_ok
---
import m as a
l = [(2, a)]
d = {k.__bool__: v for k, v in l}
---
---
---
test_import_dict_comprehension_value_usage
---
import m as a
l = [(2, a)]
d = {k: v.x for k, v in l}
---
---
3 8 UnknownValueAttributeException <imported module m as a> x
---
test_import_dict_comprehension_value_usage_ok
---
import m as a
l = [(a, 2)]
d = {k: v.__bool__ for k, v in l}
---
---
---
test_import_dict_comprehension_bad_value
---
import m as a
l = [(a, 2)]
d = {k: v.x for k, v in l}
---
---
3 8 StrictModuleUnhandledException(AttributeError)
---
test_import_function_body_ok
---
import m as a
def f(x):
    return x + a.x
---
---
---
test_import_function_body_call_usage
---
import m as a
def f(x):
    return x + a.x
f(1)
---
---
4 0 UnsafeCallException f 3 15 UnknownValueAttributeException <imported module m as a> x
---
test_import_function_call_result_usage
---
import m as a
def f(x):
    return a
f(1).x
---
---
4 0 UnknownValueAttributeException <imported module m as a> x
---
test_import_function_call_control_flow_result_usage
---
import m as a
def f(x):
    if 1 > x:
        return a
    else:
        return 42
f(0).x
---
---
7 0 UnknownValueAttributeException <imported module m as a> x
---
test_import_function_call_keyword_usage
---
import m as a
def f(x, y):
    if 1 == x:
        return y.x
    else:
        return 42
f(1, y=a)
---
---
7 0 UnsafeCallException f 4 15 UnknownValueAttributeException <imported module m as a> x
---
test_import_function_call_keyword_ok
---
import m as a
def f(x, y):
    if True:
        return x.__bool__
    else:
        return 42
f(1, y=a)
---
---
---
test_import_kw_function_call_keyword_usage
---
import m as a
def f(x, y=1, *, z, w):
    if z == w:
        return y.x
    else:
        return 42
f(1, a, z=1, w=1)
---
---
7 0 UnsafeCallException f 4 15 UnknownValueAttributeException <imported module m as a> x
---
test_import_vararg_function_call_keyword_usage
---
import m as a
def f(x, y=1, *args):
    if True:
        return args[1].x
    else:
        return 42
f(1, 2, 3, a)
---
---
7 0 UnsafeCallException f 4 15 UnknownValueAttributeException <imported module m as a> x
---
test_import_vararg_function_call_keyword_usage_tuple_index
---
import m as a
def f(x, y=1, *args):
    if True:
        return args[0].__bool__
    else:
        return 42
f(1, 2, 3, a)
---
---
---
test_import_vararg_function_call_keyword_ok
---
import m as a
def f(x, y=1, *args):
    if False:
        return y.x
    else:
        return args[0]
f(1, 2, 3, a)
---
---
---
test_import_function_call_lexical_scope
---
import a
def g():
    return x
x = a
def f():
    x = 42
    return g().y
f()
---
---
8 0 UnsafeCallException f 7 11 UnknownValueAttributeException <imported module a> y
---
test_import_function_call_lexical_scope_ok
---
import a
def g():
    return x
x = 42
def f():
    x = a
    return g().__bool__
f()
---
---
---
test_import_class_body_usage
---
import m as a
class C:
    b = a.x
---
---
3 8 UnknownValueAttributeException <imported module m as a> x
---
test_import_class_ctor_usage
---
import m as a
class C:
    def __init__(self, v):
        b = v.x
C(a)
---
---
5 0 UnsafeCallException __init__ 4 12 UnknownValueAttributeException <imported module m as a> x
---
test_import_class_ctor_ok
---
import m as a
class C:
    def __init__(self, v):
        b = v.__bool__
C(1)
---
---
---
test_import_class_attr_usage
---
import m as a
class C:
    def __init__(self, v):
        self.v = v
c = C(a)
b = c.v # ok
d = c.v.x # not ok
---
---
7 4 UnknownValueAttributeException <imported module m as a> x
---
test_import_class_method_attr_usage
---
import m as a
class C:
    def __init__(self, v):
        self.v = v

    def some_method(self):
        return self.v.x + 1
c = C(a)
b = c.v # ok
f = c.some_method # ok
d = c.some_method() # not ok
---
---
11 4 UnsafeCallException some_method 7 15 UnknownValueAttributeException <imported module m as a> x
---
test_import_class_baseclass_method_usage
---
from n import B
class C(B):
    pass

c = C()
c.f(1) # baseclass lookup
---
---
5 4 UnknownValueAttributeException <B imported from n> __new__
5 4 StrictModuleUnhandledException(TypeError)
---
test_import_lambda_usage
---
from m import a
(lambda n: n.x)(a)
---
---
2 0 UnsafeCallException <lambda> 2 11 UnknownValueAttributeException <a imported from m> x
---
test_import_lambda_assign_usage
---
from m import a
f = lambda n: n.x
f(a)
---
---
3 0 UnsafeCallException <lambda> 2 14 UnknownValueAttributeException <a imported from m> x
---
test_class_scope_hidden
---
from m import a
class C:
    b = a
    def f(self):
        c = b.x # should not be error
---
---
---
test_function_scope_visible
---
from m import a
def f():
    b = a
    class C:
        c = b.x
f()
---
---
6 0 UnsafeCallException f 5 12 UnknownValueAttributeException <a imported from m> x
---
test_nested_class_scope_usage
---
from m import a
x = a
class A:
    x = 1
    class B:
        y = x.z
---
---
6 12 UnknownValueAttributeException <a imported from m> z
---
test_nested_class_scope_ok
---
from m import a
x = 1
class A:
    x = a
    class B:
        y = x.__bool__
---
---
---
test_property
---
class C:
    @property
    def f(self):
        return 42
a = C()
b = a.f
---
b
---
---
test_property_unsafe
---
from m import a
class C:
    @property
    def f(self):
        return a.foo
c = C()
b = c.f
---
---
7 4 UnsafeCallException f 5 15 UnknownValueAttributeException <a imported from m> foo
---
test_property_getter_unsafe
---
from m import a
class C:
    @property
    def f(self):
        return 42

    @f.getter
    def f(self):
        return a.foo
c = C()
b = c.f
---
---
11 4 UnsafeCallException f 9 15 UnknownValueAttributeException <a imported from m> foo
---
test_property_setter
---
class C:
    @property
    def f(self):
        return 42

    @f.setter
    def f(self, value):
        pass

a = C()
a.f = 42
x = a.f
---
x
---
---
test_property_setter_unsafe
---
from m import a
class C:
    @property
    def f(self):
        return 42

    @f.setter
    def f(self, value):
        return a.foo

c = C()
c.f = 42
---
---
12 0 UnsafeCallException f 9 15 UnknownValueAttributeException <a imported from m> foo
---
test_property_deleter
---
class C:
    @property
    def f(self):
        return 42

    @f.deleter
    def f(self):
        pass

a = C()
del a.f
---
---
---
test_property_deleter_unsafe
---
from m import a
class C:
    @property
    def f(self):
        return 42

    @f.deleter
    def f(self):
        return a.foo

c = C()
del c.f
---
---
12 0 UnsafeCallException f 9 15 UnknownValueAttributeException <a imported from m> foo
---
test_classmethod_usage
---
from m import a
class C:
    class_var = a
    @classmethod
    def f(cls, y):
        b = cls.class_var.x
C.f(1)
---
---
7 0 UnsafeCallException f 6 12 UnknownValueAttributeException <a imported from m> x
---
test_classmethod_instance_usage
---
from m import a
class C:
    class_var = a
    @classmethod
    def f(cls, y):
        b = cls.class_var.x
c = C()
c.f(1)
---
---
8 0 UnsafeCallException f 6 12 UnknownValueAttributeException <a imported from m> x
---
test_classmethod_ok
---
from m import a
class C:
    class_var = a
    @classmethod
    def f(cls, y):
        b = cls.class_var
C.f(1)
---
---
---
test_staticmethod_instance_usage
---
from m import a
class C:
    x = 1
    @staticmethod
    def f(y, *args):
        b = y.x
C.f(a)
---
---
7 0 UnsafeCallException f 6 12 UnknownValueAttributeException <a imported from m> x
---
test_staticmethod_instance_ok
---
from m import a
class C:
    x = 1
    @staticmethod
    def f(y, *args):
        b = y.x
C.f(C)
---
---
---
test_decorator_noop_usage
---
import m as a
def dec(func):
    return func

@dec
def f(x):
    b = x.y

f(a)
---
---
9 0 UnsafeCallException f 7 8 UnknownValueAttributeException <imported module m as a> y
---
test_decorator_wrap_usage
---
import m as a
def dec(func):
    def wrapper(x):
        y = x.y
        return func(y)

    return wrapper

@dec
def f(x):
    pass

f(a)
---
---
13 0 UnsafeCallException wrapper 4 12 UnknownValueAttributeException <imported module m as a> y
---
test_decorator_side_effect_usage
---
import m as a
def dec(func):
    y = a.y
    def wrapper(x):
        return func(x)

    return wrapper

@dec
def f(x):
    pass

f(1)
---
---
9 1 UnsafeCallException dec 3 8 UnknownValueAttributeException <imported module m as a> y
13 0 UnknownValueCallException dec(f,)
---
test_decorator_side_effect_call_usage
---
import m as a
def dec(func):
    y = a
    def wrapper(x):
        return func(y)

    return wrapper

@dec
def f(x):
    b = x.y
f(1)
---
---
12 0 UnsafeCallException wrapper 5 15 UnsafeCallException f 11 8 UnknownValueAttributeException <imported module m as a> y
---
test_decorator_ok
---
import m as a
def dec(func):

    def wrapper(x):
        b = a.y
        return func(x)

    return wrapper

@dec
def f(x):
    pass
---
---
---
test_decorator_unknown
---
import m as a

@dec
def f(x):
    pass
---
---
3 1 StrictModuleUnhandledException(NameError)
---
test_separate_decorator_usage
---
from m import a

class C:
    x = 1
    def f(y, z=None):
        b = z.__bool__
    g = classmethod(f)
    h = staticmethod(f)

c1 = C.h(a) # should be ok
c2 = C.g(a) # should be error
---
---
11 5 UnsafeCallException f 6 12 UnknownValueAttributeException <a imported from m> __bool__
---
test_non_local_usage
---
from m import a
def f():
    b = 1
    def g():
        nonlocal b
        b = a
    c1 = b + 1 #ok
    g()
    return b
res = f() # ok
res.x # error
---
---
11 0 UnknownValueAttributeException <a imported from m> x
---
test_global_usage
---
from m import a
b = 1
def g():
    global b
    b = a
c1 = b.__bool__ #ok
g()
c2 = b.x # error
---
---
8 5 UnknownValueAttributeException <a imported from m> x
---
test_int_ops
---
A = 1
B = 2
C = A + B
D = A.to_bytes(2, "little")
E = C.to_bytes(2, "little")
---
D E
---
---
test_mixed_int_ops
---
from m import a
A = 1
C = A + a
---
---
3 4 UnknownValueBinaryOpException <a imported from m> + 1
---
test_mixed_int_ops_right
---
from m import a
A = 1
C = a + A
---
---
3 4 UnknownValueBinaryOpException <a imported from m> + 1
---
test_byte_ops
---
A = b'abc'
B = b'foo'
C = A + B
D = C.upper()
D
---
D
---
---
test_mixed_byte_ops_right
---
from m import a
A = b'abc'
C = A + a
---
---
3 4 UnsupportedException __add__ <a imported from m>
---
test_mixed_byte_ops
---
from m import a
A = b'abc'
C = a + A
---
---
3 4 UnknownValueBinaryOpException <a imported from m> + abc
---
test_typing_unknown
---
from typing import unknown
X = unknown('TFoo')
---
---
2 4 UnknownValueCallException <unknown imported from typing>
---
test_typing_async_iterable
---
from typing import AsyncIterable
def f(x: AsyncIterable[str]) -> None:
    pass
---
---
---
test_typing_awaitable
---
from typing import Awaitable
def f(x: Awaitable[int]) -> None:
    pass
---
---
---
test_typing_callable
---
from typing import Callable
def f(x: Callable[[int], int]) -> None:
    pass
---
---
---
test_typing_classvar
---
from typing import ClassVar
class C:
    x: ClassVar[int] = 2
---
---
---
test_typing_collection
---
from typing import Collection
def f(x: Collection[int]) -> None:
    pass
---
---
---
test_typing_context_manager
---
from typing import ContextManager
def f(x: ContextManager[int]) -> None:
    pass
---
---
---
test_typing_default_dict
---
from typing import DefaultDict
def f(x: DefaultDict[int, int]) -> None:
    pass
---
---
---
test_typing_dict
---
from typing import Dict
def f(x: Dict[str, int]) -> None:
    pass
---
---
---
test_typing_frozenset
---
from typing import FrozenSet
def f(x: FrozenSet[int]) -> None:
    pass
---
---
---
test_typing_generator
---
from typing import Generator
def f(x: Generator[int, int, int]) -> None:
    pass
---
---
---
test_typing_generic
---
from typing import TypeVar, Generic
class C(Generic[TypeVar("T")]):
    pass

a = C[int]()
---
---
---
test_typing_generic_unknown
---
from unknown import x
from typing import TypeVar, Generic
class C(Generic[TypeVar("T")], x):
    pass

---
---
3 0 UnsafeCallException __mro_entries__ 1113 15 UnknownValueAttributeException <x imported from unknown> __eq__
3 0 UnknownValueNotIterableException __mro_entries__(<_GenericAlias instance>,(<_GenericAlias instance>,<x imported from unknown>),)
---
test_typing_typevar
---
from typing import TypeVar
from m import a
T = TypeVar('T')
T.a = a
T.a.foo
---
---
5 0 UnknownValueAttributeException <a imported from m> foo
---
test_typing_iterable_2
---
from typing import Iterable
def f(x: Iterable[str]) -> None:
    pass
---
---
---
test_typing_list
---
from typing import List
def f(x: List[int]) -> None:
    pass
---
---
---
test_typing_mapping
---
from typing import Mapping
def f(x: Mapping[str, str]) -> None:
    pass
---
---
---
test_typing_mutable_mapping
---
from typing import MutableMapping
def f(x: MutableMapping[str, str]) -> None:
    pass
---
---
---
test_typing_mutable_sequence
---
from typing import MutableSequence
def f(x: MutableSequence[str]) -> None:
    pass
---
---
---
test_typing_optional
---
from typing import Optional
def f(x: Optional[int]) -> None:
    pass
---
---
---
test_typing_mutablesequence
---
from typing import MutableSequence
def f(x: MutableSequence[int]) -> None:
    pass
---
---
---
test_typing_sequence
---
from typing import Sequence
def f(x: Sequence[int]) -> None:
    pass
---
---
---
test_typing_set
---
from typing import Set
def f(x: Set[int]) -> None:
    pass
---
---
---
test_typing_tuple
---
from typing import Tuple
def f(x: Tuple[str, ...]) -> None:
    pass
---
---
---
test_typing_type
---
from typing import Type, TypeVar
class User: pass
U = TypeVar('U', bound=User)
def f(x: Type[U]) -> None:
    pass
---
---
---
test_typing_var
---
from typing import TypeVar
X = TypeVar('TFoo')
Y = X.__name__
---
---
---
test_typing_union
---
from typing import Union
def f(x: Union[int, str]) -> None:
    pass
---
---
---
test_slicing_ok
---
import m as a
x = [a, 1, 2]
y = x[1:]
b = [a.__bool__ for a in y]
---
---
---
test_slicing_fail
---
import m as a
x = [a, 1, 2]
y = x[:1]
b = [a.x for a in y]
---
---
4 5 UnknownValueAttributeException <imported module m as a> x
---
test_import_tuple_matched_assign_usage
---
import m as a
[x, y] = (1, a)
b = x.__bool__ # ok
c = y.v # not ok
---
---
4 4 UnknownValueAttributeException <imported module m as a> v
---
test_import_star
---
from m import *
---
---
1 0 StarImportDisallowedException m
---
test_import_tuple_index_usage
---
import m as a
l = (a, 1)
b = l[0].x
---
---
3 4 UnknownValueAttributeException <imported module m as a> x
---
test_private_members
---
class C:
    def __x(self):
        return 42

    def g(self):
        return self.__x()
---
---
---
test_dotted_alias_from_import
---
from a.b import c
---
---
---
test_dotted_alias_import
---
import a.b
---
---
---
test_dotted_from_imports
---
from xml.dom import SyntaxErr
---
---
---
test_dotted_imports
---
import xml.dom
---
---
---
test_decorator_with_generator
---
def mydec(gen):
    def myfunc(x):
        for i in gen:
            pass
        return x
    return myfunc

@mydec(x for x in (1, 2, 3))
def f():
    return 42
---
---
---
test_class_decorator_with_generator
---
def mydec(gen):
    def myfunc(x):
        for i in gen:
            pass
        return x
    return myfunc

@mydec(x for x in (1, 2, 3))
class C:
    x = 42
---
---
---
test_class_decorator_add_attr
---
def mydec(klass):
    klass.foo = 42
    return klass

@mydec
class C:
    x = 42

abc = C.foo.to_bytes(2, "little")
---
---
---
test_class_decorator_add_imported_attr
---
from x import a
def mydec(klass):
    klass.foo = a
    return klass

@mydec
class C:
    x = 42

abc = C.foo.x
---
---
10 6 UnknownValueAttributeException <a imported from x> x
---
test_dict
---
from x import a
x = {}
x[2] = 3
x[3] = a
z = x[2] + 1
---
---
---
test_dict_bad
---
from x import a
x = {}
x[2] = 3
x[3] = a
z = x[3] + 1
---
---
5 4 UnknownValueBinaryOpException <a imported from x> + 1
---
test_dict_str_keys
---
from x import a
x = {}
x['abc'] = 3
x['def'] = a
z = x['abc'] + 1
---
---
---
test_dict_str_keys_bad
---
from x import a
x = {}
x['abc'] = 3
x['def'] = a
x['def'] + 1
---
---
5 0 UnknownValueBinaryOpException <a imported from x> + 1
---
test_dict_tuple_keys
---
from x import a
x = {}
x[('abc', 42)] = 3
x[('abc', 100)] = a
z = x[('abc', 42)] + 1
---
---
---
test_dict_tuple_keys_bad
---
from x import a
x = {}
x[('abc', 42)] = 3
x[('abc', 100)] = a
x[('abc', 100)] + 1
---
---
5 0 UnknownValueBinaryOpException <a imported from x> + 1
---
test_dict_float_keys
---
from x import a
x = {}
x[1.0] = 3
x[2.0] = a
x[1.0] + 1
---
---
---
test_dict_float_keys_bad
---
from x import a
x = {}
x[1.0] = 3
x[2.0] = a
x[2.0] + 1
---
---
5 0 UnknownValueBinaryOpException <a imported from x> + 1
---
test_dict_complex_keys @disabled
---
from x import a
x = {}
x[1j] = 3
x[2j] = a
x[1j].to_bytes(2, "little")
---
---
---
test_dict_complex_keys_bad @disabled
---
from x import a
x = {}
x[1j] = 3
x[2j] = a
x[2j].to_bytes(2, "little")
---
---
UnknownValueAttributeException
---
test_dict_int_float_keys
---
from x import a
x = {}
x[1] = 3
x[2] = a
x[1.0] + 1
---
---
---
test_dict_int_float_keys_bad
---
from x import a
x = {}
x[1] = 3
x[2] = a
x[2.0] + 1
---
---
5 0 UnknownValueBinaryOpException <a imported from x> + 1
---
test_dict_mixed_keys
---
from x import a
x = {}
x[False] = 3
x[True] = a
x[False] + 1
---
---
---
test_dict_mixed_keys_bad
---
from x import a
x = {}
x[False] = 3
x[True] = a
x[True] + 1
---
---
5 0 UnknownValueBinaryOpException <a imported from x> + 1
---
test_for_loop_body_1
---
from outside import unknown
l = [unknown, 2, 3]
x = 1
for i in l:
    x = i
x = x + 1
---
---
---
test_dict_splat_not_mapping
---
y = {**2}
---
---
1 4 StrictModuleUnhandledException(TypeError)
---
test_dict_splat
---
x = {2:3}
y = {**x}
y[2].__bool__
---
---
---
test_dict_splat_bad
---
from a import b
x = {2:b}
y = {**x}
y[2].x # bad
---
---
4 0 UnknownValueAttributeException <b imported from a> x
---
test_dict_splat_bad_2
---
x = {2:3}
y = {**x}
y[42].abc
---
---
3 0 StrictModuleUnhandledException(KeyError)
---
test_chr_ok
---
x = chr(42)
---
---
---
test_chr_unknown_inp
---
from a import b
x = chr(b)
---
---
2 4 StrictModuleUnhandledException(TypeError)
---
test_chr_out_of_range_inp
---
x = chr(100000000)
---
---
1 4 StrictModuleUnhandledException(ValueError)
---
test_chr_wrong_arg_cnt
---
x = chr(1, 2)
---
---
1 4 StrictModuleUnhandledException(TypeError)
---
test_chr_wrong_arg_cnt_zero
---
x = chr()
---
---
1 4 StrictModuleUnhandledException(TypeError)
---
test_chr_wrong_kwarg_cnt
---
x = chr(x=2)
---
---
1 4 StrictModuleUnhandledException(TypeError)
---
test_chr_wrong_kwarg_cnt_with_param
---
x = chr(1, x=2)
---
---
1 4 StrictModuleUnhandledException(TypeError)
---
test_chr_mixed_warning_error
---
from a import b
x = chr(b, x=2)
---
---
2 4 StrictModuleUnhandledException(TypeError)
---
test_ord_ok
---
x = ord('a')
---
---
---
test_ord_unknown_inp
---
from a import b
x = ord(b)
---
---
2 4 StrictModuleUnhandledException(TypeError)
---
test_ord_invalid_input
---
x = ord("asdf")
---
---
1 4 StrictModuleUnhandledException(TypeError)
---
test_range_ok
---
x = range(1)
y = range(1,2)
z = range(3,2,1)
---
---
---
test_range_bad_arg
---
from x import a
x = range(a)
---
---
2 4 StrictModuleUnhandledException(TypeError)
---
test_list_mul_slice_ok
---
foo = [0]*42
bar = [x[:] for x in [foo]*42]
---
---
---
test_list_mul_slice_bad
---
from x import a
foo = [a]*51
bar = [x[:] for x in [foo]*51]
bar[0][1].foo
---
---
4 0 UnknownValueAttributeException <a imported from x> foo
---
test_unknown_list_index
---
from x import a, b
l = [1, a]
x = l[b]
x.foo
---
---
3 4 StrictModuleUnhandledException(TypeError)
---
test_assign_builtin_inst
---
from x import a
y = 2
y.foo = a
---
---
3 0 ImmutableException foo object 2
---
test_assign_builtin_type
---
from x import a
object.foo = a
---
---
2 0 ImmutableException foo type object
---
test_namedtuple_def_2
---
from collections import namedtuple
namedtuple("P", "x y")
---
---
---
test_namedtuple_constructor_1
---
from collections import namedtuple
P = namedtuple("P", "x y")
P(1, 2)
---
---
---
test_namedtuple_constructor_kwargs
---
from collections import namedtuple
X = namedtuple("P", "x y")
P = X.__new__(x = 2)
---
---
3 4 StrictModuleUnhandledException(TypeError)
---
test_namedtuple_bad_new
---
from collections import namedtuple
X = namedtuple("P", "x y")
X.__new__(object)
---
---
3 0 StrictModuleUnhandledException(TypeError) 113 15 StrictModuleUserException TypeError
---
test_namedtuple_index
---
from collections import namedtuple
P = namedtuple("P", "x y")
x = P(1, 2)
x[0]
---
---
---
test_namedtuple_attr
---
from collections import namedtuple
P = namedtuple("P", "x y")
p = P(1, 2)
p.x
p.y
---
---
---
test_namedtuple_sublcass_attr
---
from collections import namedtuple
B = namedtuple("P", "x y")
class P(B):
    pass
p = P(1, 2)
p.x
p.y
---
---
---
test_namedtuple_import_index
---
from collections import namedtuple
from outside import unknown
P = namedtuple("P", "x y")
p = P(1, unknown)
p[1].attr
---
---
5 0 UnknownValueAttributeException <unknown imported from outside> attr
---
test_namedtuple_import_attr
---
from collections import namedtuple
from outside import unknown
P = namedtuple("P", "x y")
p = P(1, unknown)
p.y.attr
---
---
5 0 UnknownValueAttributeException <unknown imported from outside> attr
---
test_collections_abc_mutable_mapping
---
import _collections_abc
x = _collections_abc.MutableMapping
---
---
---
test_namedtuple_rename
---
from collections import namedtuple
from outside import unknown
P = namedtuple("P", "x def", rename=True)
p = P(1, unknown)
p.x # ok
p._1.attr
---
---
6 0 UnknownValueAttributeException <unknown imported from outside> attr
---
test_namedtuple_rename_duplicate
---
from collections import namedtuple
from outside import unknown
P = namedtuple("P", "x x", rename=True)
p = P(1, unknown)
p.x # ok
p._1.attr
---
---
6 0 UnknownValueAttributeException <unknown imported from outside> attr
---
test_namedtuple_unknown_field_name
---
from collections import namedtuple
P = namedtuple("P", 1)
p = P(1)
---
---
2 4 StrictModuleUnhandledException(TypeError) 54 23 StrictModuleUserException TypeError
---
test_namedtuple_asdict
---
from collections import namedtuple
from outside import unknown
P = namedtuple("P", "x y")
p = P(1, unknown)
d = p._asdict()
d["y"].attr
---
---
6 0 UnknownValueAttributeException <unknown imported from outside> attr
---
test_namedtuple_getnewargs
---
from collections import namedtuple
from outside import unknown
P = namedtuple("P", "x y")
p = P(1, unknown)
d = p.__getnewargs__()
d[1].attr
---
---
6 0 UnknownValueAttributeException <unknown imported from outside> attr
---
test_namedtuple_make
---
from collections import namedtuple
from outside import unknown
P = namedtuple("P", "x y")
p = P._make([1, unknown])
p.y.attr
---
---
5 0 UnknownValueAttributeException <unknown imported from outside> attr
---
test_namedtuple_make_inst_call
---
from collections import namedtuple
from outside import unknown
P = namedtuple("P", "x y")
p1 = P(1, 2)
p = p1._make([1, unknown])
p.y.attr
---
---
6 0 UnknownValueAttributeException <unknown imported from outside> attr
---
test_annotations
---
class C:
    a: int
    b: bool
t = C.__annotations__
---
t
---
---
test_annotations_import
---
from outside import unknown
class C:
    a: int
    b: unknown
C.__annotations__["b"].attr
---
---
5 0 UnknownValueAttributeException <unknown imported from outside> attr
---
test_dataclass_field_access
---
from dataclasses import dataclass
from outside import unknown
@dataclass
class C:
    a: int
c = C(unknown)
c.a.attr
---
---
7 0 UnknownValueAttributeException <unknown imported from outside> attr
---
test_dataclass_subclass
---
from dataclasses import dataclass
from outside import unknown
@dataclass
class C:
    a: int
@dataclass
class D(C):
    b: int
d = D(1, unknown)
d.a # ok
d.b.attr
---
---
11 0 UnknownValueAttributeException <unknown imported from outside> attr
---
test_dataclass_field_assign
---
from dataclasses import dataclass
from outside import unknown
@dataclass
class C:
    a: object
c = C(C(1))
c.a.a # ok
c.a = unknown
c.a.attr
---
---
9 0 UnknownValueAttributeException <unknown imported from outside> attr
---
test_dataclass_non_default
---
from dataclasses import dataclass
@dataclass
class C:
    a: int = 1
    b: int
---
---
2 1 StrictModuleUnhandledException(TypeError) 1185 11 StrictModuleUserException TypeError 1176 15 StrictModuleUserException TypeError 330 27 StrictModuleUserException TypeError 546 16 StrictModuleUserException TypeError
---
test_dataclass_field
---
from dataclasses import field
from outside import unknown
f = field(init=unknown)
f.init.attr
---
---
4 0 UnknownValueAttributeException <unknown imported from outside> attr
---
test_dataclass_field_no_init
---
from dataclasses import field, dataclass
from outside import unknown
@dataclass
class C:
    a: int = field(init=False)
    def __post_init__(self):
        self.a = unknown

c = C()
c.a.attr
---
---
10 0 UnknownValueAttributeException <unknown imported from outside> attr
---
test_dataclass_init_var
---
from dataclasses import InitVar, dataclass, field
from outside import unknown
@dataclass
class C:
    a: int
    b: InitVar[int]
    c: int = field(init=False)
    def __post_init__(self, b):
        self.c = b

c = C(1, unknown)
c.c.attr
---
---
12 0 UnknownValueAttributeException <unknown imported from outside> attr
---
test_dataclass_replace_unknown
---
from dataclasses import dataclass, replace
from outside import unknown
@dataclass
class C:
    a: int

c = C(1)
c1 = replace(c, a = unknown)
c1.a.attr
---
---
9 0 UnknownValueAttributeException <unknown imported from outside> attr
---
test_dataclass_replace_initvar
---
from dataclasses import dataclass, replace, InitVar, field
from outside import unknown
@dataclass
class C:
    a: int
    b: InitVar[int]
    c: int = field(init=False)
    def __post_init__(self, b):
        self.c = b

c = C(1, 2)
c1 = replace(c, a = 1, b= unknown)
c1.c.attr
---
---
13 0 UnknownValueAttributeException <unknown imported from outside> attr
---
test_len_unknown
---
from outside import unknown
len(unknown)
---
---
2 0 UnknownValueAttributeException <unknown imported from outside> __len__
---
test_bool_ok
---
bool(1)
---
---
---
test_bool_unknown
---
from outside import unknown
bool(unknown)
---
---
2 0 UnknownValueBoolException <unknown imported from outside>
---
test_for_loop_does_replace
---
from outside import unknown
l = [unknown, 2, 3]
for i in l:
    pass
y = i.__bool__ # should be ok since i is guaranteed to be replaced
---
---
---
test_for_loop_does_replace_unsafe
---
from outside import unknown
l = [1, 2, unknown]
for i in l:
    pass
y = i.attr
---
---
5 4 UnknownValueAttributeException <unknown imported from outside> attr
---
test_for_loop_body_unsafe
---
from outside import unknown
l = [1, 2, 3, unknown]
x = 1
for i in l:
    x = i
x.attr
---
---
6 0 UnknownValueAttributeException <unknown imported from outside> attr
---
test_for_loop_class_def_empty
---
l = []
for s in l:
    class C:
        def f():
            return 1
c = C()
---
---
6 4 StrictModuleUnhandledException(NameError)
---
test_exception_branch
---
from outside import unknown
try:
    if 1 in [2]:
        x = 1
        raise Exception
    else:
        x = unknown
except Exception as e:
    pass
x.attr
---
---
10 0 UnknownValueAttributeException <unknown imported from outside> attr
---
test_exception_branch_except
---
from outside import unknown
try:
    if 1 in [2]:
        x = 1
    else:
        raise Exception
except Exception as e:
    x = unknown
x.attr
---
---
9 0 UnknownValueAttributeException <unknown imported from outside> attr
---
test_exception_loop
---
from outside import unknown
x = 2
try:
    while x == 2:
        x = 1
        raise Exception
except Exception as e:
    x = unknown
else:
    x = 2
x.attr
---
---
11 0 UnknownValueAttributeException <unknown imported from outside> attr
---
test_exception_nested
---
from outside import unknown
try:
    try:
        x = 1
        raise Exception
    except AttributeError:
        x = 2 # shouldn't run
except Exception:
    x = unknown
x.attr
---
---
10 0 UnknownValueAttributeException <unknown imported from outside> attr
---
test_exception_with_cause
---
from outside import unknown
try:
    raise AttributeError from unknown.attr
except Exception:
    pass
---
---
3 30 UnknownValueAttributeException <unknown imported from outside> attr
---
test_getattr_unknown
---
from outside import unknown
a = getattr(unknown, "a", 1)
---
---
2 4 UnknownValueAttributeException <unknown imported from outside> a
---
test_starred_assignment
---
from outside import unknown
a, *b, c = 1, unknown, 2, 3
a.__bool__
c.__bool__
b[1].__bool__
b[0].attr
---
---
6 0 UnknownValueAttributeException <unknown imported from outside> attr
---
test_starred_assignment_empty_star
---
from outside import unknown
a, *b, c = 1, unknown
a.__bool__
c.attr
---
---
4 0 UnknownValueAttributeException <unknown imported from outside> attr
---
test_starred_assignment_unknown_rest
---
from outside import unknown
a, *b, c = 1, 2, 3, unknown
a.__bool__
b[0].__bool__
b[1].__bool__
c.attr
---
---
6 0 UnknownValueAttributeException <unknown imported from outside> attr
---
test_unknown_bool_while
---
from u import x
while x:
    pass
---
---
2 0 UnknownValueBoolException <x imported from u>
---
test_unknown_bool_if
---
from u import x
if x:
    pass
---
---
2 0 UnknownValueBoolException <x imported from u>
---
test_unknown_bool_not
---
from u import x
y = not x
---
---
2 4 UnknownValueBoolException <x imported from u>
---
test_unknown_bool_cmp
---
from u import x
class C:
    def __gt__(self, other):
        return x

C() > C()
---
---
6 0 UnknownValueBoolException <x imported from u>
---
test_bool_unknown_return
---
from u import x
class C:
    def __bool__(self):
        return x

C() or 42
---
---
6 0 StrictModuleUnhandledException(TypeError)
---
test_unknown_bool_bool_op
---
from u import x
x or 42
---
---
2 0 UnknownValueBoolException <x imported from u>
---
test_unknown_bool_ifexp
---
from u import x
y = 42 if x else 23
---
---
2 4 UnknownValueBoolException <x imported from u>
---
test_unknown_bool_comp
---
from u import y
z = [x for x in [1,2,3] if y]
---
---
2 4 UnknownValueBoolException <y imported from u>
2 4 UnknownValueBoolException <y imported from u>
2 4 UnknownValueBoolException <y imported from u>
---
test_scoping_generators_first_iter
---
x = [x for x in (lambda: [1,2,3])()]
---
x
---
---
test_metaclass_violation_init
---
import unknown

class mc(type):
    def __init__(self, name, bases, dict):
        unknown.path.append('foo')

class x(metaclass=mc):
    pass
---
---
7 0 UnsafeCallException __init__ 5 8 UnknownValueAttributeException <imported module unknown> path
---
test_metaclass_violation_new
---
import unknown

class mc(type):
    def __new__(cls, name, bases, dict):
        unknown.path.append('foo')

class x(metaclass=mc):
    pass
---
---
7 0 UnsafeCallException __new__ 5 8 UnknownValueAttributeException <imported module unknown> path
---
test_metaclass_okay
---
import sys

class mc(type):
    def __init__(self, name, bases, dict):
        self.foo = 42

class x(metaclass=mc):
    pass

y = x.foo.to_bytes(2, "little")
---
---
---
test_metaclass_unknown
---
from a import B

class X(metaclass=B):
    pass
---
---
3 0 UnknownValueCallException <B imported from a>
3 0 UnknownValueCallException <B imported from a>
---
test_metaclass_conflict
---

class MX(type): pass
class MY(type): pass

class X(metaclass=MX): pass
class Y(metaclass=MY): pass

class Z(X, Y): pass
---
---
8 0 StrictModuleUnhandledException(TypeError)
---
test_object_new_not_enough_args
---

x = object.__new__()
---
---
2 4 StrictModuleUnhandledException(TypeError)
---
test_object_new_too_many_args
---

x = object.__new__(object, 42)
---
---
---
test_object_new_okay
---

x = object.__new__(object)
---
---
---
test_object_new_non_type
---

x = object.__new__(42)
---
---
2 4 StrictModuleUnhandledException(TypeError)
---
test_object_creates_instance
---
from a import b

class C:
    x = b

object.__new__(C).x.blah
---
---
6 0 UnknownValueAttributeException <b imported from a> blah
---
test_type_no_args
---
type()
---
---
1 0 StrictModuleUnhandledException(TypeError)
---
test_type_too_many_args
---
type(1, 2, 3, 4)
---
---
1 0 StrictModuleUnhandledException(TypeError)
---
test_type_bad_name
---
type(42, (), {})
---
---
1 0 StrictModuleUnhandledException(TypeError)
---
test_type_bad_bases
---
type('foo', 'abc', {})
---
---
1 0 StrictModuleUnhandledException(TypeError)
---
test_type_bad_dict
---
type('foo', (), 42.0)
---
---
1 0 StrictModuleUnhandledException(TypeError)
---
test_type_bad_base
---
type('foo', (42, ), {})
---
---
1 0 UnsafeBaseClassException 42
---
test_classmethod_subclass_2
---
class x(classmethod): pass
---
---
---
test_slice_list_assignment_okay
---
from a import b
x = [b]
x[:] = [1,2,3]
x[0] + 1
---
---
---
test_slice_list_assignment_bad
---
from a import b
x = [1,2,3]
x[:] = [b]
x[0] + 1
---
---
4 0 UnknownValueBinaryOpException <b imported from a> + 1
---
test_bad_base_type_range
---
class C(range):
    pass
---
---
1 0 StrictModuleUnhandledException(TypeError)
---
test_bad_base_type_bool
---
class C(bool):
    pass
---
---
1 0 StrictModuleUnhandledException(TypeError)
---
test_inconsistent_hierarchy
---
class C(object, int):
    pass
---
---
1 0 StrictModuleUnhandledException(TypeError)
---
test_base_conflict_layout
---
class C(int, bytes):
    pass
---
---
1 0 StrictModuleUnhandledException(TypeError)
---
test_classproperty
---
class classproperty:
    def __init__(self, getter):
        self._getter = getter

    def __get__(self, instance, owner):
        return self._getter(owner)


@classproperty
def f(self):
    pass
---
---
---
test_del_builtin
---
int = 1
x = int
del int
y = int(2.0)
---
x y
---
---
test_strict_flag
---
import other, __strict__
x = 1
---
---
1 0 BadStrictFlagException strict flag may not be combined with other imports
---
test_flag_after_doc
---
'''First docstring.'''
import __strict__
x = 1
---
x
---
---
test_flag_after_two_doc
---
'''First docstring.'''
'''Second "docstring."'''
import __strict__
x = 1
---
---
3 0 BadStrictFlagException strict flag must be at top of module
---
test_flag_after_import
---
import foo
import __strict__
---
---
2 0 BadStrictFlagException strict flag must be at top of module
---
test_duplicate_flag
---
import __strict__
import foo
import __strict__
---
---
3 0 BadStrictFlagException strict flag must be at top of module
---
test_flag_with_imports
---
import __strict__, foo
---
---
1 0 BadStrictFlagException strict flag may not be combined with other imports
---
test_flag_alias
---
import __strict__ as foo
---
---
1 0 BadStrictFlagException strict flag may not be aliased
---
test_abc
---
from abc import ABC, abstractmethod, abstractclassmethod, abstractstaticmethod, abstractproperty

class A(ABC):
    @abstractclassmethod
    def cm(self):
        pass
    @abstractmethod
    def f(self):
        pass
    @abstractstaticmethod
    def sm():
        pass
    @abstractproperty
    def prop(self):
        pass


a  = A.f.__isabstractmethod__
b = A.cm.__isabstractmethod__
c = A.sm.__isabstractmethod__
d = A.prop.__isabstractmethod__
---
a b c d
---
---
test_abc_override
---
from abc import ABC, abstractmethod

class Abstract(ABC):
    @abstractmethod
    def f(self):
        ...

class Concrete(Abstract):
    def f(self):
        return 42

a = Concrete().f()
---
a
---
---
test_enum
---
from enum import IntEnum

class C(IntEnum):
    X = 1
    Y = 2

xn = C.X.name
yn = C.Y.name
xv = C.X.value
yv = C.Y.value
---
xn yn xv yv
---
---
test_inspect
---
import inspect

def f(a, b, c):
    pass

isfunc = inspect.isfunction(f)
isnotfunc = inspect.isfunction(42)
params = list(inspect.signature(f).parameters)
---
isfunc isnotfunc params
---
---
test_bytes_maketrans
---
i = b"abc"
j = b"def"
x = bytes.maketrans(i, j)
---
x
---
---
test_raise_assertion_error
---
def assert_fail():
    raise AssertionError()

assert_fail()
---
---
4 0 StrictModuleUnhandledException(AssertionError) 2 4 StrictModuleUserException AssertionError
---
test_members_has_dunder_module
---
class MetaType(type):
    def __new__(cls, name, bases, members):
        print(members["__module__"])
        return type.__new__(cls, name, bases, members)

class NewType(metaclass=MetaType):
    pass
---
---
---
test_id_does_not_name_error
---
a = id
---
---
---
test_id_call_on_toplevel_errors
---
a = id()
---
---
1 4 UnknownValueCallException id
---
NotImplementedError
---
NotImplementedError
---
---
---
test_generic_alias_instancecheck
---
l = list[int]
x = isinstance([], l)
---
---
2 4 StrictModuleUnhandledException(TypeError)
---
test_generic_alias_subclasscheck
---
l = list[int]
x = issubclass(list, l)
---
---
2 4 StrictModuleUnhandledException(TypeError)
---
