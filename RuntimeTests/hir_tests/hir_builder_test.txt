HIRBuilderTest
---
---
TestReturnNone
---
def test():
  return None
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadConst<NoneType>
    Return v0
  }
}
---
TestReturnArg
---
def test(x):
  return x
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    Return v0
  }
}
---
TestCompare
---
def test(a, b):
  return a is b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = PrimitiveCompare<Equal> v0 v1
    v3 = PrimitiveBoxBool v2
    Return v3
  }
}
---
TestConditionallyAssignLocal
---
def test(a):
    if a:
        b = "foo"
    return b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v2 = IsTruthy v0 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
      }
    }
    CondBranch<1, 2> v2
  }

  bb 1 (preds 0) {
    v3 = LoadConst<MortalUnicodeExact["foo"]>
    v1 = Assign v3
    Branch<2>
  }

  bb 2 (preds 0, 1) {
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 10
        Locals<2> v0 v1
      }
    }
    Return v1
  }
}
---
TestLoadAttr
---
def test(self):
  return self.foo
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "self">
    v0 = CheckVar<"self"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = LoadAttr<0; "foo"> v0 {
      FrameState {
        NextInstrOffset 4
        Locals<1> v0
      }
    }
    Return v1
  }
}
---
TestCondBranch
---
def test(x):
  if x:
    return True
  return False
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = IsTruthy v0 {
      FrameState {
        NextInstrOffset 4
        Locals<1> v0
      }
    }
    CondBranch<1, 2> v1
  }

  bb 1 (preds 0) {
    v2 = LoadConst<ImmortalBool[True]>
    Return v2
  }

  bb 2 (preds 0) {
    v3 = LoadConst<ImmortalBool[False]>
    Return v3
  }
}
---
TestCall
---
def test(f, x, y, z):
  return f(x, y, z)
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "f">
    v1 = LoadArg<1; "x">
    v2 = LoadArg<2; "y">
    v3 = LoadArg<3; "z">
    v0 = CheckVar<"f"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<4> v0 v1 v2 v3
      }
    }
    v1 = CheckVar<"x"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<4> v0 v1 v2 v3
        Stack<1> v0
      }
    }
    v2 = CheckVar<"y"> v2 {
      FrameState {
        NextInstrOffset 6
        Locals<4> v0 v1 v2 v3
        Stack<2> v0 v1
      }
    }
    v3 = CheckVar<"z"> v3 {
      FrameState {
        NextInstrOffset 8
        Locals<4> v0 v1 v2 v3
        Stack<3> v0 v1 v2
      }
    }
    v4 = VectorCall<3> v0 v1 v2 v3 {
      FrameState {
        NextInstrOffset 10
        Locals<4> v0 v1 v2 v3
      }
    }
    Return v4
  }
}
---
TestAssign
---
def test():
  x = 100
  return x
---
fun jittestmodule:test {
  bb 0 {
    v1 = LoadConst<ImmortalLongExact[100]>
    v0 = Assign v1
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 6
        Locals<1> v0
      }
    }
    Return v0
  }
}
---
InsertJumpsForBlocksThatFallThrough
---
def test(x):
  if x:
    y = 100
  return y
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v2 = IsTruthy v0 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
      }
    }
    CondBranch<1, 2> v2
  }

  bb 1 (preds 0) {
    v3 = LoadConst<ImmortalLongExact[100]>
    v1 = Assign v3
    Branch<2>
  }

  bb 2 (preds 0, 1) {
    v1 = CheckVar<"y"> v1 {
      FrameState {
        NextInstrOffset 10
        Locals<2> v0 v1
      }
    }
    Return v1
  }
}
---
HandlesIncomingStacksInCanonicalForm
---
def test(x):
  y = True if x else False
  return y
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v2 = IsTruthy v0 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
      }
    }
    CondBranch<1, 2> v2
  }

  bb 1 (preds 0) {
    v3 = LoadConst<ImmortalBool[True]>
    v1 = Assign v3
    v1 = CheckVar<"y"> v1 {
      FrameState {
        NextInstrOffset 10
        Locals<2> v0 v1
      }
    }
    Return v1
  }

  bb 2 (preds 0) {
    v4 = LoadConst<ImmortalBool[False]>
    v1 = Assign v4
    v1 = CheckVar<"y"> v1 {
      FrameState {
        NextInstrOffset 18
        Locals<2> v0 v1
      }
    }
    Return v1
  }
}
---
InsertsCopiesToCanonicalizeStacks
---
def test(x, y):
  z = x if x else y
  return z
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v1 = LoadArg<1; "y">
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<3> v0 v1 v2
      }
    }
    v3 = IsTruthy v0 {
      FrameState {
        NextInstrOffset 4
        Locals<3> v0 v1 v2
      }
    }
    CondBranch<1, 2> v3
  }

  bb 1 (preds 0) {
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 6
        Locals<3> v0 v1 v2
      }
    }
    v2 = Assign v0
    v2 = CheckVar<"z"> v2 {
      FrameState {
        NextInstrOffset 10
        Locals<3> v0 v1 v2
      }
    }
    Return v2
  }

  bb 2 (preds 0) {
    v1 = CheckVar<"y"> v1 {
      FrameState {
        NextInstrOffset 14
        Locals<3> v0 v1 v2
      }
    }
    v2 = Assign v1
    v2 = CheckVar<"z"> v2 {
      FrameState {
        NextInstrOffset 18
        Locals<3> v0 v1 v2
      }
    }
    Return v2
  }
}
---
TranslatesJumpIfFalseOrPop
---
def test(x, y):
  return x and y
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v1 = LoadArg<1; "y">
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v2 = IsTruthy v0 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v3 = Assign v0
    CondBranch<1, 2> v2
  }

  bb 1 (preds 0) {
    v1 = CheckVar<"y"> v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    v3 = Assign v1
    Branch<2>
  }

  bb 2 (preds 0, 1) {
    Return v3
  }
}
---
TranslatesJumpIfTrueOrPop
---
def test(x, y):
  return x or y
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v1 = LoadArg<1; "y">
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v2 = IsTruthy v0 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v3 = Assign v0
    CondBranch<2, 1> v2
  }

  bb 1 (preds 0) {
    v1 = CheckVar<"y"> v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    v3 = Assign v1
    Branch<2>
  }

  bb 2 (preds 0, 1) {
    Return v3
  }
}
---
TranslatesLoadGlobal
---
def test():
  return len
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadGlobalCached<0; "len">
    v0 = GuardIs<0xdeadbeef> v0 {
      Descr 'LOAD_GLOBAL: len'
    }
    Return v0
  }
}
---
TranslatesStoreAttr
---
def test(x, val):
  x.foo = val
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v1 = LoadArg<1; "val">
    v1 = CheckVar<"val"> v1 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v1
      }
    }
    v2 = StoreAttr<0; "foo"> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
TranslatesPopTop
---
def test(f, x):
  f(x)
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "f">
    v1 = LoadArg<1; "x">
    v0 = CheckVar<"f"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"x"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = VectorCall<1> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
TranslatesPopJumpIfTrue
---
def test(x):
  if not x:
    return False
  return True
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = IsTruthy v0 {
      FrameState {
        NextInstrOffset 4
        Locals<1> v0
      }
    }
    CondBranch<2, 1> v1
  }

  bb 2 (preds 0) {
    v2 = LoadConst<ImmortalBool[True]>
    Return v2
  }

  bb 1 (preds 0) {
    v3 = LoadConst<ImmortalBool[False]>
    Return v3
  }
}
---
TranslatesAddPacket
---
def test(self, p, old):
    if self.input is None:
        self.input = p
        self.packet_pending = True
        if self.priority > old.priority:
            return self
    else:
        p.append_to(self.input)
    return old
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "self">
    v1 = LoadArg<1; "p">
    v2 = LoadArg<2; "old">
    v0 = CheckVar<"self"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<3> v0 v1 v2
      }
    }
    v3 = LoadAttr<0; "input"> v0 {
      FrameState {
        NextInstrOffset 4
        Locals<3> v0 v1 v2
      }
    }
    v4 = LoadConst<NoneType>
    v5 = PrimitiveCompare<Equal> v3 v4
    v6 = PrimitiveBoxBool v5
    v7 = IsTruthy v6 {
      FrameState {
        NextInstrOffset 10
        Locals<3> v0 v1 v2
      }
    }
    CondBranch<1, 4> v7
  }

  bb 1 (preds 0) {
    v1 = CheckVar<"p"> v1 {
      FrameState {
        NextInstrOffset 12
        Locals<3> v0 v1 v2
      }
    }
    v0 = CheckVar<"self"> v0 {
      FrameState {
        NextInstrOffset 14
        Locals<3> v0 v1 v2
        Stack<1> v1
      }
    }
    v8 = StoreAttr<0; "input"> v0 v1 {
      FrameState {
        NextInstrOffset 16
        Locals<3> v0 v1 v2
      }
    }
    v9 = LoadConst<ImmortalBool[True]>
    v0 = CheckVar<"self"> v0 {
      FrameState {
        NextInstrOffset 20
        Locals<3> v0 v1 v2
        Stack<1> v9
      }
    }
    v10 = StoreAttr<1; "packet_pending"> v0 v9 {
      FrameState {
        NextInstrOffset 22
        Locals<3> v0 v1 v2
      }
    }
    v0 = CheckVar<"self"> v0 {
      FrameState {
        NextInstrOffset 24
        Locals<3> v0 v1 v2
      }
    }
    v11 = LoadAttr<2; "priority"> v0 {
      FrameState {
        NextInstrOffset 26
        Locals<3> v0 v1 v2
      }
    }
    v2 = CheckVar<"old"> v2 {
      FrameState {
        NextInstrOffset 28
        Locals<3> v0 v1 v2
        Stack<1> v11
      }
    }
    v12 = LoadAttr<2; "priority"> v2 {
      FrameState {
        NextInstrOffset 30
        Locals<3> v0 v1 v2
        Stack<1> v11
      }
    }
    v13 = Compare<GreaterThan> v11 v12 {
      FrameState {
        NextInstrOffset 32
        Locals<3> v0 v1 v2
      }
    }
    v14 = IsTruthy v13 {
      FrameState {
        NextInstrOffset 34
        Locals<3> v0 v1 v2
      }
    }
    CondBranch<2, 3> v14
  }

  bb 2 (preds 1) {
    v0 = CheckVar<"self"> v0 {
      FrameState {
        NextInstrOffset 36
        Locals<3> v0 v1 v2
      }
    }
    Return v0
  }

  bb 3 (preds 1) {
    v2 = CheckVar<"old"> v2 {
      FrameState {
        NextInstrOffset 40
        Locals<3> v0 v1 v2
      }
    }
    Return v2
  }

  bb 4 (preds 0) {
    v1 = CheckVar<"p"> v1 {
      FrameState {
        NextInstrOffset 44
        Locals<3> v0 v1 v2
      }
    }
    v15 = LoadMethod<3; "append_to"> v1 {
      FrameState {
        NextInstrOffset 46
        Locals<3> v0 v1 v2
      }
    }
    v16 = GetSecondOutput<OptObject> v15
    v0 = CheckVar<"self"> v0 {
      FrameState {
        NextInstrOffset 48
        Locals<3> v0 v1 v2
        Stack<2> v15 v16
      }
    }
    v17 = LoadAttr<0; "input"> v0 {
      FrameState {
        NextInstrOffset 50
        Locals<3> v0 v1 v2
        Stack<2> v15 v16
      }
    }
    v18 = CallMethod<3> v15 v16 v17 {
      FrameState {
        NextInstrOffset 52
        Locals<3> v0 v1 v2
      }
    }
    v2 = CheckVar<"old"> v2 {
      FrameState {
        NextInstrOffset 56
        Locals<3> v0 v1 v2
      }
    }
    Return v2
  }
}
---
TranslatesLoops
---
def test(x, y):
  while x:
    x = y()
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v1 = LoadArg<1; "y">
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v2 = IsTruthy v0 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
      }
    }
    CondBranch<4, 3> v2
  }

  bb 4 (preds 0, 1) {
    v7 = LoadEvalBreaker
    CondBranch<5, 1> v7
  }

  bb 5 (preds 4) {
    v8 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
      }
    }
    Branch<1>
  }

  bb 1 (preds 4, 5) {
    v1 = CheckVar<"y"> v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    v3 = VectorCall<0> v1 {
      FrameState {
        NextInstrOffset 8
        Locals<2> v0 v1
      }
    }
    v0 = Assign v3
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 12
        Locals<2> v0 v1
      }
    }
    v4 = IsTruthy v0 {
      FrameState {
        NextInstrOffset 14
        Locals<2> v0 v1
      }
    }
    CondBranch<4, 2> v4
  }

  bb 2 (preds 1) {
    v6 = LoadConst<NoneType>
    Return v6
  }

  bb 3 (preds 0) {
    v5 = LoadConst<NoneType>
    Return v5
  }
}
---
TranslateBlocksWithOnlySetupLoop0
---
def test(self):
    if not self:
        return
    while True:
        self = 1
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "self">
    v0 = CheckVar<"self"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = IsTruthy v0 {
      FrameState {
        NextInstrOffset 4
        Locals<1> v0
      }
    }
    CondBranch<4, 1> v1
  }

  bb 4 (preds 0, 3) {
    v4 = LoadEvalBreaker
    CondBranch<5, 3> v4
  }

  bb 5 (preds 4) {
    v5 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 10
        Locals<1> v0
      }
    }
    Branch<3>
  }

  bb 3 (preds 4, 5) {
    v3 = LoadConst<ImmortalLongExact[1]>
    v0 = Assign v3
    Branch<4>
  }

  bb 1 (preds 0) {
    v2 = LoadConst<NoneType>
    Return v2
  }
}
---
TranslateBlocksWithOnlySetupLoop1
---
def test(self):
    while True:
        self = 1
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "self">
    Branch<2>
  }

  bb 2 (preds 0, 1) {
    v2 = LoadEvalBreaker
    CondBranch<3, 1> v2
  }

  bb 3 (preds 2) {
    v3 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    Branch<1>
  }

  bb 1 (preds 2, 3) {
    v1 = LoadConst<ImmortalLongExact[1]>
    v0 = Assign v1
    Branch<2>
  }
}
---
EmitCheckExcForGreaterThan
---
def test(x):
  return x > 1
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = LoadConst<ImmortalLongExact[1]>
    v2 = Compare<GreaterThan> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<1> v0
      }
    }
    Return v2
  }
}
---
EmitCheckExcForGreaterThanEqual
---
def test(x):
  return x >= 1
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = LoadConst<ImmortalLongExact[1]>
    v2 = Compare<GreaterThanEqual> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<1> v0
      }
    }
    Return v2
  }
}
---
EmitCheckExcForLessThan
---
def test(x):
  return x < 1
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = LoadConst<ImmortalLongExact[1]>
    v2 = Compare<LessThan> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<1> v0
      }
    }
    Return v2
  }
}
---
EmitCheckExcForLessThanEqual
---
def test(x):
  return x <= 1
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = LoadConst<ImmortalLongExact[1]>
    v2 = Compare<LessThanEqual> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<1> v0
      }
    }
    Return v2
  }
}
---
EmitCheckExcForEqual
---
def test(x):
  return x == 1
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = LoadConst<ImmortalLongExact[1]>
    v2 = Compare<Equal> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<1> v0
      }
    }
    Return v2
  }
}
---
EmitCheckExcForNotEqual
---
def test(x):
  return x != 1
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = LoadConst<ImmortalLongExact[1]>
    v2 = Compare<NotEqual> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<1> v0
      }
    }
    Return v2
  }
}
---
EmitCheckExcForIn
---
def test(x, s):
  return x in s
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v1 = LoadArg<1; "s">
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"s"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = Compare<In> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Return v2
  }
}
---
EmitCheckExcForNotIn
---
def test(x, s):
  return x not in s
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v1 = LoadArg<1; "s">
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"s"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = Compare<NotIn> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Return v2
  }
}
---
DoesntEmitCheckExcForIs
---
def test(x):
  return x is None
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = LoadConst<NoneType>
    v2 = PrimitiveCompare<Equal> v0 v1
    v3 = PrimitiveBoxBool v2
    Return v3
  }
}
---
DoesntEmitCheckExcForIsNot
---
def test(x):
  return x is not None
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = LoadConst<NoneType>
    v2 = PrimitiveCompare<NotEqual> v0 v1
    v3 = PrimitiveBoxBool v2
    Return v3
  }
}
---
TranslatesBinaryAdd
---
def test(a, b):
  return a + b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = BinaryOp<Add> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Return v2
  }
}
---
TranslatesBinaryAnd
---
def test(a, b):
  return a & b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = BinaryOp<And> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Return v2
  }
}
---
TranslatesBinaryFloorDivide
---
def test(a, b):
  return a // b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = BinaryOp<FloorDivide> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Return v2
  }
}
---
TranslatesBinaryLShift
---
def test(a, b):
  return a << b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = BinaryOp<LShift> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Return v2
  }
}
---
TranslatesBinaryModulo
---
def test(a, b):
  return a % b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = BinaryOp<Modulo> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Return v2
  }
}
---
TranslatesBinaryMultiply
---
def test(a, b):
  return a * b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = BinaryOp<Multiply> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Return v2
  }
}
---
TranslatesBinaryOr
---
def test(a, b):
  return a | b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = BinaryOp<Or> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Return v2
  }
}
---
TranslatesBinaryPower
---
def test(a, b):
  return a ** b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = BinaryOp<Power> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Return v2
  }
}
---
TranslatesBinaryRShift
---
def test(a, b):
  return a >> b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = BinaryOp<RShift> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Return v2
  }
}
---
TranslatesBinarySubscr
---
def test(a, b):
  return a[b]
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = BinaryOp<Subscript> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Return v2
  }
}
---
TranslatesBinarySubtract
---
def test(a, b):
  return a - b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = BinaryOp<Subtract> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Return v2
  }
}
---
TranslatesBinaryTrueDivide
---
def test(a, b):
  return a / b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = BinaryOp<TrueDivide> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Return v2
  }
}
---
TranslatesBinaryXor
---
def test(a, b):
  return a ^ b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = BinaryOp<Xor> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Return v2
  }
}
---
BuildTuple
---
def test(a):
  return (a, a, a)
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 4
        Locals<1> v0
        Stack<1> v0
      }
    }
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 6
        Locals<1> v0
        Stack<2> v0 v0
      }
    }
    v1 = MakeTuple<3> v0 v0 v0 {
      FrameState {
        NextInstrOffset 8
        Locals<1> v0
        Stack<3> v0 v0 v0
      }
    }
    Return v1
  }
}
---
BuildList
---
def test(a):
  return [a, a, a]
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 4
        Locals<1> v0
        Stack<1> v0
      }
    }
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 6
        Locals<1> v0
        Stack<2> v0 v0
      }
    }
    v1 = MakeList<3> v0 v0 v0 {
      FrameState {
        NextInstrOffset 8
        Locals<1> v0
        Stack<3> v0 v0 v0
      }
    }
    Return v1
  }
}
---
UnaryNot
---
def test(a):
  return not a
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = UnaryOp<Not> v0 {
      FrameState {
        NextInstrOffset 4
        Locals<1> v0
      }
    }
    Return v1
  }
}
---
UnaryPositive
---
def test(a):
  return +a
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = UnaryOp<Positive> v0 {
      FrameState {
        NextInstrOffset 4
        Locals<1> v0
      }
    }
    Return v1
  }
}
---
UnaryNegative
---
def test(a):
  return -a
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = UnaryOp<Negate> v0 {
      FrameState {
        NextInstrOffset 4
        Locals<1> v0
      }
    }
    Return v1
  }
}
---
UnaryInvert
---
def test(a):
  return ~a
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = UnaryOp<Invert> v0 {
      FrameState {
        NextInstrOffset 4
        Locals<1> v0
      }
    }
    Return v1
  }
}
---
StoreSubscr
---
def test(c, s, v):
  c[s] = v
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "c">
    v1 = LoadArg<1; "s">
    v2 = LoadArg<2; "v">
    v2 = CheckVar<"v"> v2 {
      FrameState {
        NextInstrOffset 2
        Locals<3> v0 v1 v2
      }
    }
    v0 = CheckVar<"c"> v0 {
      FrameState {
        NextInstrOffset 4
        Locals<3> v0 v1 v2
        Stack<1> v2
      }
    }
    v1 = CheckVar<"s"> v1 {
      FrameState {
        NextInstrOffset 6
        Locals<3> v0 v1 v2
        Stack<2> v2 v0
      }
    }
    v3 = StoreSubscr v0 v1 v2 {
      FrameState {
        NextInstrOffset 8
        Locals<3> v0 v1 v2
      }
    }
    v4 = LoadConst<NoneType>
    Return v4
  }
}
---
InPlaceAdd
---
def test(a, b):
  a += b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = InPlaceOp<Add> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    v0 = Assign v2
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
InPlaceAnd
---
def test(a, b):
  a &= b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = InPlaceOp<And> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    v0 = Assign v2
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
InPlaceFloorDivide
---
def test(a, b):
  a //= b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = InPlaceOp<FloorDivide> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    v0 = Assign v2
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
InPlaceLShift
---
def test(a, b):
  a <<= b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = InPlaceOp<LShift> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    v0 = Assign v2
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
InPlaceMatrixMultiply
---
def test(a, b):
  a @= b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = InPlaceOp<MatrixMultiply> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    v0 = Assign v2
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
InPlaceModulo
---
def test(a, b):
  a %= b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = InPlaceOp<Modulo> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    v0 = Assign v2
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
InPlaceOr
---
def test(a, b):
  a |= b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = InPlaceOp<Or> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    v0 = Assign v2
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
InPlacePower
---
def test(a, b):
  a **= b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = InPlaceOp<Power> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    v0 = Assign v2
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
InPlaceRShift
---
def test(a, b):
  a >>= b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = InPlaceOp<RShift> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    v0 = Assign v2
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
InPlaceSubtract
---
def test(a, b):
  a -= b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = InPlaceOp<Subtract> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    v0 = Assign v2
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
InPlaceTrueDivide
---
def test(a, b):
  a /= b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = InPlaceOp<TrueDivide> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    v0 = Assign v2
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
InPlaceXor
---
def test(a, b):
  a ^= b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = InPlaceOp<Xor> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    v0 = Assign v2
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
InPlaceAddNotDefined
---
def test():
  a += b
---
fun jittestmodule:test {
  bb 0 {
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = LoadGlobal<0; "b"> {
      FrameState {
        NextInstrOffset 4
        Locals<1> v0
        Stack<1> v0
      }
    }
    v2 = InPlaceOp<Add> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<1> v0
      }
    }
    v0 = Assign v2
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
BuildMap
---
def test(k, v):
  return {k: v, 12: 34}
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "k">
    v1 = LoadArg<1; "v">
    v0 = CheckVar<"k"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"v"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = LoadConst<ImmortalLongExact[12]>
    v3 = LoadConst<ImmortalLongExact[34]>
    v4 = MakeDict<2> {
      FrameState {
        NextInstrOffset 10
        Locals<2> v0 v1
        Stack<4> v0 v1 v2 v3
      }
    }
    v5 = SetDictItem v4 v0 v1 {
      FrameState {
        NextInstrOffset 10
        Locals<2> v0 v1
        Stack<4> v0 v1 v2 v3
      }
    }
    v6 = SetDictItem v4 v2 v3 {
      FrameState {
        NextInstrOffset 10
        Locals<2> v0 v1
        Stack<4> v0 v1 v2 v3
      }
    }
    Return v4
  }
}
---
BuildConstKeyMap
---
def test():
  return {"a key": "a value", 0xdead: 0xbeef}
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadConst<MortalUnicodeExact["a value"]>
    v1 = LoadConst<MortalLongExact[48879]>
    v2 = LoadConst<MortalTupleExact[tuple:0xdeadbeef]>
    v3 = MakeDict<2> {
      FrameState {
        NextInstrOffset 8
        Stack<3> v0 v1 v2
      }
    }
    v4 = LoadTupleItem<0> v2
    v5 = SetDictItem v3 v4 v0 {
      FrameState {
        NextInstrOffset 8
        Stack<2> v0 v1
      }
    }
    v6 = LoadTupleItem<1> v2
    v7 = SetDictItem v3 v6 v1 {
      FrameState {
        NextInstrOffset 8
        Stack<2> v0 v1
      }
    }
    Return v3
  }
}
---
ExtendedArg
---
def test(
    a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15,
    a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29,
    a30, a31, a32, a33, a34, a35, a36, a37, a38, a39, a40, a41, a42, a43,
    a44, a45, a46, a47, a48, a49, a50, a51, a52, a53, a54, a55, a56, a57,
    a58, a59, a60, a61, a62, a63, a64, a65, a66, a67, a68, a69, a70, a71,
    a72, a73, a74, a75, a76, a77, a78, a79, a80, a81, a82, a83, a84, a85,
    a86, a87, a88, a89, a90, a91, a92, a93, a94, a95, a96, a97, a98, a99,
    a100, a101, a102, a103, a104, a105, a106, a107, a108, a109, a110,
    a111, a112, a113, a114, a115, a116, a117, a118, a119, a120, a121,
    a122, a123, a124, a125, a126, a127, a128, a129, a130, a131, a132,
    a133, a134, a135, a136, a137, a138, a139, a140, a141, a142, a143,
    a144, a145, a146, a147, a148, a149, a150, a151, a152, a153, a154,
    a155, a156, a157, a158, a159, a160, a161, a162, a163, a164, a165,
    a166, a167, a168, a169, a170, a171, a172, a173, a174, a175, a176,
    a177, a178, a179, a180, a181, a182, a183, a184, a185, a186, a187,
    a188, a189, a190, a191, a192, a193, a194, a195, a196, a197, a198,
    a199, a200, a201, a202, a203, a204, a205, a206, a207, a208, a209,
    a210, a211, a212, a213, a214, a215, a216, a217, a218, a219, a220,
    a221, a222, a223, a224, a225, a226, a227, a228, a229, a230, a231,
    a232, a233, a234, a235, a236, a237, a238, a239, a240, a241, a242,
    a243, a244, a245, a246, a247, a248, a249, a250, a251, a252, a253,
    a254, a255
  ):
    a10 = 1
    a256 = 1337
    return a256
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a0">
    v1 = LoadArg<1; "a1">
    v2 = LoadArg<2; "a2">
    v3 = LoadArg<3; "a3">
    v4 = LoadArg<4; "a4">
    v5 = LoadArg<5; "a5">
    v6 = LoadArg<6; "a6">
    v7 = LoadArg<7; "a7">
    v8 = LoadArg<8; "a8">
    v9 = LoadArg<9; "a9">
    v10 = LoadArg<10; "a10">
    v11 = LoadArg<11; "a11">
    v12 = LoadArg<12; "a12">
    v13 = LoadArg<13; "a13">
    v14 = LoadArg<14; "a14">
    v15 = LoadArg<15; "a15">
    v16 = LoadArg<16; "a16">
    v17 = LoadArg<17; "a17">
    v18 = LoadArg<18; "a18">
    v19 = LoadArg<19; "a19">
    v20 = LoadArg<20; "a20">
    v21 = LoadArg<21; "a21">
    v22 = LoadArg<22; "a22">
    v23 = LoadArg<23; "a23">
    v24 = LoadArg<24; "a24">
    v25 = LoadArg<25; "a25">
    v26 = LoadArg<26; "a26">
    v27 = LoadArg<27; "a27">
    v28 = LoadArg<28; "a28">
    v29 = LoadArg<29; "a29">
    v30 = LoadArg<30; "a30">
    v31 = LoadArg<31; "a31">
    v32 = LoadArg<32; "a32">
    v33 = LoadArg<33; "a33">
    v34 = LoadArg<34; "a34">
    v35 = LoadArg<35; "a35">
    v36 = LoadArg<36; "a36">
    v37 = LoadArg<37; "a37">
    v38 = LoadArg<38; "a38">
    v39 = LoadArg<39; "a39">
    v40 = LoadArg<40; "a40">
    v41 = LoadArg<41; "a41">
    v42 = LoadArg<42; "a42">
    v43 = LoadArg<43; "a43">
    v44 = LoadArg<44; "a44">
    v45 = LoadArg<45; "a45">
    v46 = LoadArg<46; "a46">
    v47 = LoadArg<47; "a47">
    v48 = LoadArg<48; "a48">
    v49 = LoadArg<49; "a49">
    v50 = LoadArg<50; "a50">
    v51 = LoadArg<51; "a51">
    v52 = LoadArg<52; "a52">
    v53 = LoadArg<53; "a53">
    v54 = LoadArg<54; "a54">
    v55 = LoadArg<55; "a55">
    v56 = LoadArg<56; "a56">
    v57 = LoadArg<57; "a57">
    v58 = LoadArg<58; "a58">
    v59 = LoadArg<59; "a59">
    v60 = LoadArg<60; "a60">
    v61 = LoadArg<61; "a61">
    v62 = LoadArg<62; "a62">
    v63 = LoadArg<63; "a63">
    v64 = LoadArg<64; "a64">
    v65 = LoadArg<65; "a65">
    v66 = LoadArg<66; "a66">
    v67 = LoadArg<67; "a67">
    v68 = LoadArg<68; "a68">
    v69 = LoadArg<69; "a69">
    v70 = LoadArg<70; "a70">
    v71 = LoadArg<71; "a71">
    v72 = LoadArg<72; "a72">
    v73 = LoadArg<73; "a73">
    v74 = LoadArg<74; "a74">
    v75 = LoadArg<75; "a75">
    v76 = LoadArg<76; "a76">
    v77 = LoadArg<77; "a77">
    v78 = LoadArg<78; "a78">
    v79 = LoadArg<79; "a79">
    v80 = LoadArg<80; "a80">
    v81 = LoadArg<81; "a81">
    v82 = LoadArg<82; "a82">
    v83 = LoadArg<83; "a83">
    v84 = LoadArg<84; "a84">
    v85 = LoadArg<85; "a85">
    v86 = LoadArg<86; "a86">
    v87 = LoadArg<87; "a87">
    v88 = LoadArg<88; "a88">
    v89 = LoadArg<89; "a89">
    v90 = LoadArg<90; "a90">
    v91 = LoadArg<91; "a91">
    v92 = LoadArg<92; "a92">
    v93 = LoadArg<93; "a93">
    v94 = LoadArg<94; "a94">
    v95 = LoadArg<95; "a95">
    v96 = LoadArg<96; "a96">
    v97 = LoadArg<97; "a97">
    v98 = LoadArg<98; "a98">
    v99 = LoadArg<99; "a99">
    v100 = LoadArg<100; "a100">
    v101 = LoadArg<101; "a101">
    v102 = LoadArg<102; "a102">
    v103 = LoadArg<103; "a103">
    v104 = LoadArg<104; "a104">
    v105 = LoadArg<105; "a105">
    v106 = LoadArg<106; "a106">
    v107 = LoadArg<107; "a107">
    v108 = LoadArg<108; "a108">
    v109 = LoadArg<109; "a109">
    v110 = LoadArg<110; "a110">
    v111 = LoadArg<111; "a111">
    v112 = LoadArg<112; "a112">
    v113 = LoadArg<113; "a113">
    v114 = LoadArg<114; "a114">
    v115 = LoadArg<115; "a115">
    v116 = LoadArg<116; "a116">
    v117 = LoadArg<117; "a117">
    v118 = LoadArg<118; "a118">
    v119 = LoadArg<119; "a119">
    v120 = LoadArg<120; "a120">
    v121 = LoadArg<121; "a121">
    v122 = LoadArg<122; "a122">
    v123 = LoadArg<123; "a123">
    v124 = LoadArg<124; "a124">
    v125 = LoadArg<125; "a125">
    v126 = LoadArg<126; "a126">
    v127 = LoadArg<127; "a127">
    v128 = LoadArg<128; "a128">
    v129 = LoadArg<129; "a129">
    v130 = LoadArg<130; "a130">
    v131 = LoadArg<131; "a131">
    v132 = LoadArg<132; "a132">
    v133 = LoadArg<133; "a133">
    v134 = LoadArg<134; "a134">
    v135 = LoadArg<135; "a135">
    v136 = LoadArg<136; "a136">
    v137 = LoadArg<137; "a137">
    v138 = LoadArg<138; "a138">
    v139 = LoadArg<139; "a139">
    v140 = LoadArg<140; "a140">
    v141 = LoadArg<141; "a141">
    v142 = LoadArg<142; "a142">
    v143 = LoadArg<143; "a143">
    v144 = LoadArg<144; "a144">
    v145 = LoadArg<145; "a145">
    v146 = LoadArg<146; "a146">
    v147 = LoadArg<147; "a147">
    v148 = LoadArg<148; "a148">
    v149 = LoadArg<149; "a149">
    v150 = LoadArg<150; "a150">
    v151 = LoadArg<151; "a151">
    v152 = LoadArg<152; "a152">
    v153 = LoadArg<153; "a153">
    v154 = LoadArg<154; "a154">
    v155 = LoadArg<155; "a155">
    v156 = LoadArg<156; "a156">
    v157 = LoadArg<157; "a157">
    v158 = LoadArg<158; "a158">
    v159 = LoadArg<159; "a159">
    v160 = LoadArg<160; "a160">
    v161 = LoadArg<161; "a161">
    v162 = LoadArg<162; "a162">
    v163 = LoadArg<163; "a163">
    v164 = LoadArg<164; "a164">
    v165 = LoadArg<165; "a165">
    v166 = LoadArg<166; "a166">
    v167 = LoadArg<167; "a167">
    v168 = LoadArg<168; "a168">
    v169 = LoadArg<169; "a169">
    v170 = LoadArg<170; "a170">
    v171 = LoadArg<171; "a171">
    v172 = LoadArg<172; "a172">
    v173 = LoadArg<173; "a173">
    v174 = LoadArg<174; "a174">
    v175 = LoadArg<175; "a175">
    v176 = LoadArg<176; "a176">
    v177 = LoadArg<177; "a177">
    v178 = LoadArg<178; "a178">
    v179 = LoadArg<179; "a179">
    v180 = LoadArg<180; "a180">
    v181 = LoadArg<181; "a181">
    v182 = LoadArg<182; "a182">
    v183 = LoadArg<183; "a183">
    v184 = LoadArg<184; "a184">
    v185 = LoadArg<185; "a185">
    v186 = LoadArg<186; "a186">
    v187 = LoadArg<187; "a187">
    v188 = LoadArg<188; "a188">
    v189 = LoadArg<189; "a189">
    v190 = LoadArg<190; "a190">
    v191 = LoadArg<191; "a191">
    v192 = LoadArg<192; "a192">
    v193 = LoadArg<193; "a193">
    v194 = LoadArg<194; "a194">
    v195 = LoadArg<195; "a195">
    v196 = LoadArg<196; "a196">
    v197 = LoadArg<197; "a197">
    v198 = LoadArg<198; "a198">
    v199 = LoadArg<199; "a199">
    v200 = LoadArg<200; "a200">
    v201 = LoadArg<201; "a201">
    v202 = LoadArg<202; "a202">
    v203 = LoadArg<203; "a203">
    v204 = LoadArg<204; "a204">
    v205 = LoadArg<205; "a205">
    v206 = LoadArg<206; "a206">
    v207 = LoadArg<207; "a207">
    v208 = LoadArg<208; "a208">
    v209 = LoadArg<209; "a209">
    v210 = LoadArg<210; "a210">
    v211 = LoadArg<211; "a211">
    v212 = LoadArg<212; "a212">
    v213 = LoadArg<213; "a213">
    v214 = LoadArg<214; "a214">
    v215 = LoadArg<215; "a215">
    v216 = LoadArg<216; "a216">
    v217 = LoadArg<217; "a217">
    v218 = LoadArg<218; "a218">
    v219 = LoadArg<219; "a219">
    v220 = LoadArg<220; "a220">
    v221 = LoadArg<221; "a221">
    v222 = LoadArg<222; "a222">
    v223 = LoadArg<223; "a223">
    v224 = LoadArg<224; "a224">
    v225 = LoadArg<225; "a225">
    v226 = LoadArg<226; "a226">
    v227 = LoadArg<227; "a227">
    v228 = LoadArg<228; "a228">
    v229 = LoadArg<229; "a229">
    v230 = LoadArg<230; "a230">
    v231 = LoadArg<231; "a231">
    v232 = LoadArg<232; "a232">
    v233 = LoadArg<233; "a233">
    v234 = LoadArg<234; "a234">
    v235 = LoadArg<235; "a235">
    v236 = LoadArg<236; "a236">
    v237 = LoadArg<237; "a237">
    v238 = LoadArg<238; "a238">
    v239 = LoadArg<239; "a239">
    v240 = LoadArg<240; "a240">
    v241 = LoadArg<241; "a241">
    v242 = LoadArg<242; "a242">
    v243 = LoadArg<243; "a243">
    v244 = LoadArg<244; "a244">
    v245 = LoadArg<245; "a245">
    v246 = LoadArg<246; "a246">
    v247 = LoadArg<247; "a247">
    v248 = LoadArg<248; "a248">
    v249 = LoadArg<249; "a249">
    v250 = LoadArg<250; "a250">
    v251 = LoadArg<251; "a251">
    v252 = LoadArg<252; "a252">
    v253 = LoadArg<253; "a253">
    v254 = LoadArg<254; "a254">
    v255 = LoadArg<255; "a255">
    v257 = LoadConst<ImmortalLongExact[1]>
    v10 = Assign v257
    v258 = LoadConst<MortalLongExact[1337]>
    v256 = Assign v258
    v256 = CheckVar<"a256"> v256 {
      FrameState {
        NextInstrOffset 14
        Locals<257> v0 v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11 v12 v13 v14 v15 v16 v17 v18 v19 v20 v21 v22 v23 v24 v25 v26 v27 v28 v29 v30 v31 v32 v33 v34 v35 v36 v37 v38 v39 v40 v41 v42 v43 v44 v45 v46 v47 v48 v49 v50 v51 v52 v53 v54 v55 v56 v57 v58 v59 v60 v61 v62 v63 v64 v65 v66 v67 v68 v69 v70 v71 v72 v73 v74 v75 v76 v77 v78 v79 v80 v81 v82 v83 v84 v85 v86 v87 v88 v89 v90 v91 v92 v93 v94 v95 v96 v97 v98 v99 v100 v101 v102 v103 v104 v105 v106 v107 v108 v109 v110 v111 v112 v113 v114 v115 v116 v117 v118 v119 v120 v121 v122 v123 v124 v125 v126 v127 v128 v129 v130 v131 v132 v133 v134 v135 v136 v137 v138 v139 v140 v141 v142 v143 v144 v145 v146 v147 v148 v149 v150 v151 v152 v153 v154 v155 v156 v157 v158 v159 v160 v161 v162 v163 v164 v165 v166 v167 v168 v169 v170 v171 v172 v173 v174 v175 v176 v177 v178 v179 v180 v181 v182 v183 v184 v185 v186 v187 v188 v189 v190 v191 v192 v193 v194 v195 v196 v197 v198 v199 v200 v201 v202 v203 v204 v205 v206 v207 v208 v209 v210 v211 v212 v213 v214 v215 v216 v217 v218 v219 v220 v221 v222 v223 v224 v225 v226 v227 v228 v229 v230 v231 v232 v233 v234 v235 v236 v237 v238 v239 v240 v241 v242 v243 v244 v245 v246 v247 v248 v249 v250 v251 v252 v253 v254 v255 v256
      }
    }
    Return v256
  }
}
---
BuildSliceNoStep
---
def test(a):
  return a[1:5]
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = LoadConst<ImmortalLongExact[1]>
    v2 = LoadConst<ImmortalLongExact[5]>
    v3 = BuildSlice<2> v1 v2 {
      FrameState {
        NextInstrOffset 8
        Locals<1> v0
        Stack<1> v0
      }
    }
    v4 = BinaryOp<Subscript> v0 v3 {
      FrameState {
        NextInstrOffset 10
        Locals<1> v0
      }
    }
    Return v4
  }
}
---
BuildSliceWithStep
---
def test(a):
  return a[100:20:-2]
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = LoadConst<ImmortalLongExact[100]>
    v2 = LoadConst<ImmortalLongExact[20]>
    v3 = LoadConst<ImmortalLongExact[-2]>
    v4 = BuildSlice<3> v1 v2 v3 {
      FrameState {
        NextInstrOffset 10
        Locals<1> v0
        Stack<1> v0
      }
    }
    v5 = BinaryOp<Subscript> v0 v4 {
      FrameState {
        NextInstrOffset 12
        Locals<1> v0
      }
    }
    Return v5
  }
}
---
ReassignsOnStackRegistersOnOverwrite
---
def test(a, b):
  a, b = b, a
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v1
      }
    }
    v2 = Assign v0
    v0 = Assign v1
    v1 = Assign v2
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
HandlesEmptyInfiniteLoops
---
def test():
  while True:
    pass

---
fun jittestmodule:test {
  bb 0 {
    Branch<2>
  }

  bb 2 (preds 0, 2, 3) {
    v0 = LoadEvalBreaker
    CondBranch<3, 2> v0
  }

  bb 3 (preds 2) {
    v1 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
      }
    }
    Branch<2>
  }
}
---
ForIterTest
---
def test(xs):
  for x in xs:
    print(x)
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "xs">
    v0 = CheckVar<"xs"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v2 = GetIter v0 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
      }
    }
    Branch<4>
  }

  bb 4 (preds 0, 2) {
    v7 = LoadEvalBreaker
    CondBranch<5, 1> v7
  }

  bb 5 (preds 4) {
    v8 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v2
      }
    }
    Branch<1>
  }

  bb 1 (preds 4, 5) {
    v3 = InvokeIterNext v2 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
        Stack<1> v2
      }
    }
    CondBranchIterNotDone<2, 3> v3
  }

  bb 2 (preds 1) {
    v1 = Assign v3
    v4 = LoadGlobalCached<0; "print">
    v4 = GuardIs<0xdeadbeef> v4 {
      Descr 'LOAD_GLOBAL: print'
    }
    v1 = CheckVar<"x"> v1 {
      FrameState {
        NextInstrOffset 12
        Locals<2> v0 v1
        Stack<2> v2 v4
      }
    }
    v5 = VectorCall<1> v4 v1 {
      FrameState {
        NextInstrOffset 14
        Locals<2> v0 v1
        Stack<1> v2
      }
    }
    Branch<4>
  }

  bb 3 (preds 1) {
    v6 = LoadConst<NoneType>
    Return v6
  }
}
---
ListComprehension
---
def test(a):
  return [i for i in a]
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v2 = MakeList<0> {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v2
      }
    }
    v3 = GetIter v0 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
        Stack<1> v2
      }
    }
    Branch<4>
  }

  bb 4 (preds 0, 2) {
    v6 = LoadEvalBreaker
    CondBranch<5, 1> v6
  }

  bb 5 (preds 4) {
    v7 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
        Stack<2> v2 v3
      }
    }
    Branch<1>
  }

  bb 1 (preds 4, 5) {
    v4 = InvokeIterNext v3 {
      FrameState {
        NextInstrOffset 8
        Locals<2> v0 v1
        Stack<2> v2 v3
      }
    }
    CondBranchIterNotDone<2, 3> v4
  }

  bb 2 (preds 1) {
    v1 = Assign v4
    v1 = CheckVar<"i"> v1 {
      FrameState {
        NextInstrOffset 12
        Locals<2> v0 v1
        Stack<2> v2 v3
      }
    }
    v5 = ListAppend v2 v1 {
      FrameState {
        NextInstrOffset 14
        Locals<2> v0 v1
        Stack<2> v2 v3
      }
    }
    Branch<4>
  }

  bb 3 (preds 1) {
    v1 = LoadConst<Nullptr>
    Return v2
  }
}
---
NestedFunction
---
def test(a):
  def nested(a=a):
    return a
  return nested
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v2 = MakeTuple<1> v0 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v3 = LoadConst<MortalCode["nested"]>
    v4 = LoadConst<MortalUnicodeExact["test.<locals>.nested"]>
    v5 = MakeFunction v4 v3 {
      FrameState {
        NextInstrOffset 10
        Locals<2> v0 v1
        Stack<1> v2
      }
    }
    SetFunctionAttr<func_defaults> v2 v5
    v1 = Assign v5
    v1 = CheckVar<"nested"> v1 {
      FrameState {
        NextInstrOffset 14
        Locals<2> v0 v1
      }
    }
    Return v1
  }
}
---
Cellvar
---
def test():
  a = 1
  def g():
    return a
  return g
---
fun jittestmodule:test {
  bb 0 {
    v1 = MakeCell v2 {
      FrameState {
        NextInstrOffset 0
        Locals<1> v0
        Cells<1> v1
      }
    }
    v3 = LoadConst<ImmortalLongExact[1]>
    v4 = StealCellItem v1
    SetCellItem v1 v3 v4
    v5 = MakeTuple<1> v1 {
      FrameState {
        NextInstrOffset 8
        Locals<1> v0
        Cells<1> v1
        Stack<1> v1
      }
    }
    v6 = LoadConst<MortalCode["g"]>
    v7 = LoadConst<MortalUnicodeExact["test.<locals>.g"]>
    v8 = MakeFunction v7 v6 {
      FrameState {
        NextInstrOffset 14
        Locals<1> v0
        Cells<1> v1
        Stack<1> v5
      }
    }
    SetFunctionAttr<func_closure> v5 v8
    v0 = Assign v8
    v0 = CheckVar<"g"> v0 {
      FrameState {
        NextInstrOffset 18
        Locals<1> v0
        Cells<1> v1
      }
    }
    Return v0
  }
}
---
CellvarArgument
---
def test(a):
  def g():
    return a
  return g
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v2 = MakeCell v0 {
      FrameState {
        NextInstrOffset 0
        Locals<2> v0 v1
        Cells<1> v2
      }
    }
    v4 = MakeTuple<1> v2 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v3 v1
        Cells<1> v2
        Stack<1> v2
      }
    }
    v5 = LoadConst<MortalCode["g"]>
    v6 = LoadConst<MortalUnicodeExact["test.<locals>.g"]>
    v7 = MakeFunction v6 v5 {
      FrameState {
        NextInstrOffset 10
        Locals<2> v3 v1
        Cells<1> v2
        Stack<1> v4
      }
    }
    SetFunctionAttr<func_closure> v4 v7
    v1 = Assign v7
    v1 = CheckVar<"g"> v1 {
      FrameState {
        NextInstrOffset 14
        Locals<2> v3 v1
        Cells<1> v2
      }
    }
    Return v1
  }
}
---
CellvarWithStackLoadAndBlockCanonicalization
---
def test(a):
  def g():
    return a
  for x in g():
    pass
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v3 = MakeCell v0 {
      FrameState {
        NextInstrOffset 0
        Locals<3> v0 v1 v2
        Cells<1> v3
      }
    }
    v5 = MakeTuple<1> v3 {
      FrameState {
        NextInstrOffset 4
        Locals<3> v4 v1 v2
        Cells<1> v3
        Stack<1> v3
      }
    }
    v6 = LoadConst<MortalCode["g"]>
    v7 = LoadConst<MortalUnicodeExact["test.<locals>.g"]>
    v8 = MakeFunction v7 v6 {
      FrameState {
        NextInstrOffset 10
        Locals<3> v4 v1 v2
        Cells<1> v3
        Stack<1> v5
      }
    }
    SetFunctionAttr<func_closure> v5 v8
    v1 = Assign v8
    v1 = CheckVar<"g"> v1 {
      FrameState {
        NextInstrOffset 14
        Locals<3> v4 v1 v2
        Cells<1> v3
      }
    }
    v9 = VectorCall<0> v1 {
      FrameState {
        NextInstrOffset 16
        Locals<3> v4 v1 v2
        Cells<1> v3
      }
    }
    v10 = GetIter v9 {
      FrameState {
        NextInstrOffset 18
        Locals<3> v4 v1 v2
        Cells<1> v3
      }
    }
    v5 = Assign v10
    Branch<4>
  }

  bb 4 (preds 0, 2) {
    v13 = LoadEvalBreaker
    CondBranch<5, 1> v13
  }

  bb 5 (preds 4) {
    v14 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 18
        Locals<3> v4 v1 v2
        Cells<1> v3
        Stack<1> v5
      }
    }
    Branch<1>
  }

  bb 1 (preds 4, 5) {
    v11 = InvokeIterNext v5 {
      FrameState {
        NextInstrOffset 20
        Locals<3> v4 v1 v2
        Cells<1> v3
        Stack<1> v5
      }
    }
    v6 = Assign v11
    CondBranchIterNotDone<2, 3> v6
  }

  bb 2 (preds 1) {
    v2 = Assign v6
    Branch<4>
  }

  bb 3 (preds 1) {
    v12 = LoadConst<NoneType>
    Return v12
  }
}
---
LoopWithBreak1
---
def test():
  while True:
    break
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadConst<NoneType>
    Return v0
  }
}
---
LoopWithBreak2
---
def test(x, y):
  while x < 10:
    if x == y:
      break
    x += 1
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v1 = LoadArg<1; "y">
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v2 = LoadConst<ImmortalLongExact[10]>
    v3 = Compare<LessThan> v0 v2 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    v4 = IsTruthy v3 {
      FrameState {
        NextInstrOffset 8
        Locals<2> v0 v1
      }
    }
    CondBranch<6, 5> v4
  }

  bb 6 (preds 0, 3) {
    v15 = LoadEvalBreaker
    CondBranch<7, 1> v15
  }

  bb 7 (preds 6) {
    v16 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 8
        Locals<2> v0 v1
      }
    }
    Branch<1>
  }

  bb 1 (preds 6, 7) {
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 10
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"y"> v1 {
      FrameState {
        NextInstrOffset 12
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v5 = Compare<Equal> v0 v1 {
      FrameState {
        NextInstrOffset 14
        Locals<2> v0 v1
      }
    }
    v6 = IsTruthy v5 {
      FrameState {
        NextInstrOffset 16
        Locals<2> v0 v1
      }
    }
    CondBranch<2, 3> v6
  }

  bb 2 (preds 1) {
    v8 = LoadConst<NoneType>
    Return v8
  }

  bb 3 (preds 1) {
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 22
        Locals<2> v0 v1
      }
    }
    v9 = LoadConst<ImmortalLongExact[1]>
    v10 = InPlaceOp<Add> v0 v9 {
      FrameState {
        NextInstrOffset 26
        Locals<2> v0 v1
      }
    }
    v0 = Assign v10
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 30
        Locals<2> v0 v1
      }
    }
    v11 = LoadConst<ImmortalLongExact[10]>
    v12 = Compare<LessThan> v0 v11 {
      FrameState {
        NextInstrOffset 34
        Locals<2> v0 v1
      }
    }
    v13 = IsTruthy v12 {
      FrameState {
        NextInstrOffset 36
        Locals<2> v0 v1
      }
    }
    CondBranch<6, 4> v13
  }

  bb 4 (preds 3) {
    v14 = LoadConst<NoneType>
    Return v14
  }

  bb 5 (preds 0) {
    v7 = LoadConst<NoneType>
    Return v7
  }
}
---
LoopWithBreak3
---
def test(x):
  for i in [1, 2]:
    if i > x:
      break
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v2 = LoadConst<MortalTupleExact[tuple:0xdeadbeef]>
    v3 = GetIter v2 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
      }
    }
    v2 = Assign v3
    Branch<6>
  }

  bb 6 (preds 0, 2) {
    v9 = LoadEvalBreaker
    CondBranch<7, 1> v9
  }

  bb 7 (preds 6) {
    v10 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v2
      }
    }
    Branch<1>
  }

  bb 1 (preds 6, 7) {
    v4 = InvokeIterNext v2 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
        Stack<1> v2
      }
    }
    v3 = Assign v4
    CondBranchIterNotDone<2, 5> v3
  }

  bb 2 (preds 1) {
    v1 = Assign v3
    v1 = CheckVar<"i"> v1 {
      FrameState {
        NextInstrOffset 10
        Locals<2> v0 v1
        Stack<1> v2
      }
    }
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 12
        Locals<2> v0 v1
        Stack<2> v2 v1
      }
    }
    v5 = Compare<GreaterThan> v1 v0 {
      FrameState {
        NextInstrOffset 14
        Locals<2> v0 v1
        Stack<1> v2
      }
    }
    v6 = IsTruthy v5 {
      FrameState {
        NextInstrOffset 16
        Locals<2> v0 v1
        Stack<1> v2
      }
    }
    CondBranch<3, 6> v6
  }

  bb 3 (preds 2) {
    v8 = LoadConst<NoneType>
    Return v8
  }

  bb 5 (preds 1) {
    v7 = LoadConst<NoneType>
    Return v7
  }
}
---
ImportName
---
def test():
  import test_import
---
fun jittestmodule:test {
  bb 0 {
    v1 = LoadConst<ImmortalLongExact[0]>
    v2 = LoadConst<NoneType>
    v3 = ImportName<0; "test_import"> v2 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<1> v0
      }
    }
    v0 = Assign v3
    v4 = LoadConst<NoneType>
    Return v4
  }
}
---
EscapedName
---
def test(a):
    return a.foo

c = test.__code__
new_names = ("a\nrea\\lly\n\"weird\"\nname", )
test.__code__ = type(c)(
    c.co_argcount,
    c.co_posonlyargcount,
    c.co_kwonlyargcount,
    c.co_nlocals,
    c.co_stacksize,
    c.co_flags,
    c.co_code,
    c.co_consts,
    new_names,
    c.co_varnames,
    c.co_filename,
    c.co_name,
    c.co_firstlineno,
    c.co_lnotab,
    c.co_freevars,
    c.co_cellvars,
)
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = LoadAttr<0; "a\nrea\\lly\n\"weird\"\nname"> v0 {
      FrameState {
        NextInstrOffset 4
        Locals<1> v0
      }
    }
    Return v1
  }
}
---
GetIterOutputNotOnStack
---
def test():
    while True:
        args = ["-W%s" % o for o in warnopts]
        if args:
            return
---
fun jittestmodule:test {
  bb 0 {
    Branch<7>
  }

  bb 7 (preds 0, 4) {
    v11 = LoadEvalBreaker
    CondBranch<8, 1> v11
  }

  bb 8 (preds 7) {
    v12 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    Branch<1>
  }

  bb 1 (preds 7, 8) {
    v2 = MakeList<0> {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
      }
    }
    v3 = LoadGlobal<0; "warnopts"> {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
        Stack<1> v2
      }
    }
    v4 = GetIter v3 {
      FrameState {
        NextInstrOffset 8
        Locals<2> v0 v1
        Stack<1> v2
      }
    }
    v3 = Assign v4
    Branch<9>
  }

  bb 9 (preds 1, 3) {
    v13 = LoadEvalBreaker
    CondBranch<10, 2> v13
  }

  bb 10 (preds 9) {
    v14 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 8
        Locals<2> v0 v1
        Stack<2> v2 v3
      }
    }
    Branch<2>
  }

  bb 2 (preds 9, 10) {
    v5 = InvokeIterNext v3 {
      FrameState {
        NextInstrOffset 10
        Locals<2> v0 v1
        Stack<2> v2 v3
      }
    }
    v4 = Assign v5
    CondBranchIterNotDone<3, 4> v4
  }

  bb 3 (preds 2) {
    v0 = Assign v4
    v6 = LoadConst<MortalUnicodeExact["-W%s"]>
    v0 = CheckVar<"o"> v0 {
      FrameState {
        NextInstrOffset 16
        Locals<2> v0 v1
        Stack<3> v2 v3 v6
      }
    }
    v7 = BinaryOp<Modulo> v6 v0 {
      FrameState {
        NextInstrOffset 18
        Locals<2> v0 v1
        Stack<2> v2 v3
      }
    }
    v8 = ListAppend v2 v7 {
      FrameState {
        NextInstrOffset 20
        Locals<2> v0 v1
        Stack<2> v2 v3
      }
    }
    Branch<9>
  }

  bb 4 (preds 2) {
    v0 = LoadConst<Nullptr>
    v1 = Assign v2
    v1 = CheckVar<"args"> v1 {
      FrameState {
        NextInstrOffset 28
        Locals<2> v0 v1
      }
    }
    v9 = IsTruthy v1 {
      FrameState {
        NextInstrOffset 30
        Locals<2> v0 v1
      }
    }
    CondBranch<5, 7> v9
  }

  bb 5 (preds 4) {
    v10 = LoadConst<NoneType>
    Return v10
  }
}
---
MaintainsIsolatedEntry
---
def test():
    while True:
        x = foo()
        if x != 0:
            return x
---
fun jittestmodule:test {
  bb 0 {
    Branch<4>
  }

  bb 4 (preds 0, 1) {
    v6 = LoadEvalBreaker
    CondBranch<5, 1> v6
  }

  bb 5 (preds 4) {
    v7 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    Branch<1>
  }

  bb 1 (preds 4, 5) {
    v1 = LoadGlobal<0; "foo"> {
      FrameState {
        NextInstrOffset 4
        Locals<1> v0
      }
    }
    v2 = VectorCall<0> v1 {
      FrameState {
        NextInstrOffset 6
        Locals<1> v0
      }
    }
    v0 = Assign v2
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 10
        Locals<1> v0
      }
    }
    v3 = LoadConst<ImmortalLongExact[0]>
    v4 = Compare<NotEqual> v0 v3 {
      FrameState {
        NextInstrOffset 14
        Locals<1> v0
      }
    }
    v5 = IsTruthy v4 {
      FrameState {
        NextInstrOffset 16
        Locals<1> v0
      }
    }
    CondBranch<2, 4> v5
  }

  bb 2 (preds 1) {
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 18
        Locals<1> v0
      }
    }
    Return v0
  }
}
---
TestFString
---
def test(a, b):
    c = f"{a}"
    d = f"{b:02}"
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<4> v0 v1 v2 v3
      }
    }
    v4 = LoadConst<Nullptr>
    v5 = FormatValue<None> v4 v0 {
      FrameState {
        NextInstrOffset 4
        Locals<4> v0 v1 v2 v3
      }
    }
    v2 = Assign v5
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 8
        Locals<4> v0 v1 v2 v3
      }
    }
    v6 = LoadConst<MortalUnicodeExact["02"]>
    v7 = FormatValue<None> v6 v1 {
      FrameState {
        NextInstrOffset 12
        Locals<4> v0 v1 v2 v3
      }
    }
    v3 = Assign v7
    v8 = LoadConst<NoneType>
    Return v8
  }
}
---
TestAsyncFor
---
async def test(asyncgen):
  async for y in asyncgen:
    print(y)
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "asyncgen">
    v2 = InitialYield {
      FrameState {
        NextInstrOffset 0
        Locals<2> v0 v1
      }
    }
    v0 = CheckVar<"asyncgen"> v0 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
      }
    }
    v3 = GetAIter v0 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Branch<6>
  }

  bb 6 (preds 0, 4) {
    v12 = LoadEvalBreaker
    CondBranch<7, 1> v12
  }

  bb 7 (preds 6) {
    v13 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 8
        Locals<2> v0 v1
        Stack<1> v3
        BlockStack {
          Opcode 122 HandlerOff 28 StackLevel 1
        }
      }
    }
    Branch<1>
  }

  bb 1 (preds 6, 7) {
    v4 = GetANext v3 {
      FrameState {
        NextInstrOffset 10
        Locals<2> v0 v1
        Stack<1> v3
        BlockStack {
          Opcode 122 HandlerOff 28 StackLevel 1
        }
      }
    }
    v5 = LoadConst<NoneType>
    SetCurrentAwaiter v4
    v6 = YieldFromHandleStopAsyncIteration v5 v4 {
      FrameState {
        NextInstrOffset 14
        Locals<2> v0 v1
        Stack<2> v3 v4
        BlockStack {
          Opcode 122 HandlerOff 28 StackLevel 1
        }
      }
    }
    v4 = Assign v6
    CondBranchIterNotDone<2, 3> v4
  }

  bb 2 (preds 1) {
    v7 = LoadEvalBreaker
    CondBranch<5, 4> v7
  }

  bb 5 (preds 2) {
    v8 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 16
        Locals<2> v0 v1
        Stack<2> v3 v4
        BlockStack {
          Opcode 122 HandlerOff 28 StackLevel 1
        }
      }
    }
    Branch<4>
  }

  bb 4 (preds 2, 5) {
    v1 = Assign v4
    v9 = LoadGlobalCached<0; "print">
    v9 = GuardIs<0xdeadbeef> v9 {
      Descr 'LOAD_GLOBAL: print'
    }
    v1 = CheckVar<"y"> v1 {
      FrameState {
        NextInstrOffset 22
        Locals<2> v0 v1
        Stack<2> v3 v9
      }
    }
    v10 = VectorCall<1> v9 v1 {
      FrameState {
        NextInstrOffset 24
        Locals<2> v0 v1
        Stack<1> v3
      }
    }
    Branch<6>
  }

  bb 3 (preds 1) {
    v11 = LoadConst<NoneType>
    Return v11
  }
}
---
TestMakeSet
---
def test():
  return {1,2,3}
---
fun jittestmodule:test {
  bb 0 {
    v0 = MakeSet {
      FrameState {
        NextInstrOffset 2
      }
    }
    v1 = LoadConst<MortalObjectUser[frozenset:0xdeadbeef]>
    v2 = SetUpdate v0 v1 {
      FrameState {
        NextInstrOffset 6
        Stack<1> v0
      }
    }
    Return v0
  }
}
---
StarargsIsRefinedToTupleExact
---
def test(x, y, *args):
  return args
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v1 = LoadArg<1; "y">
    v2 = LoadArg<2; "args", TupleExact>
    v2 = CheckVar<"args"> v2 {
      FrameState {
        NextInstrOffset 2
        Locals<3> v0 v1 v2
      }
    }
    Return v2
  }
}
---
StarargsIsRefinedToTupleExactWithKwonlyArgs
---
def test(x, y, *args, kwonly=None):
  return args
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v1 = LoadArg<1; "y">
    v2 = LoadArg<2; "kwonly">
    v3 = LoadArg<3; "args", TupleExact>
    v3 = CheckVar<"args"> v3 {
      FrameState {
        NextInstrOffset 2
        Locals<4> v0 v1 v2 v3
      }
    }
    Return v3
  }
}
---
