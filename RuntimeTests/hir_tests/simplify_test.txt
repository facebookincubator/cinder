SimplifyTest
---
Simplify
---
LoadTupleItemToLoadConst
---
def test(a, b):
    baddict = {
        "aaa": a,
        "bbb": b}

    return baddict
---
fun jittestmodule:test {
  bb 0 {
    v9:Object = LoadArg<0; "a">
    v10:Object = LoadArg<1; "b">
    v11:Nullptr = LoadConst<Nullptr>
    v14:MortalTupleExact[tuple:0xdeadbeef] = LoadConst<MortalTupleExact[tuple:0xdeadbeef]>
    v15:MortalDictExact = MakeDict<2> {
      FrameState {
        NextInstrOffset 8
        Locals<3> v9 v10 v11
        Stack<3> v9 v10 v14
      }
    }
    UseType<MortalTupleExact[tuple:0xdeadbeef]> v14
    v22:MortalUnicodeExact["aaa"] = LoadConst<MortalUnicodeExact["aaa"]>
    v17:CInt32 = SetDictItem v15 v22 v9 {
      FrameState {
        NextInstrOffset 8
        Locals<3> v9 v10 v11
        Stack<2> v9 v10
      }
    }
    UseType<MortalTupleExact[tuple:0xdeadbeef]> v14
    v23:MortalUnicodeExact["bbb"] = LoadConst<MortalUnicodeExact["bbb"]>
    v19:CInt32 = SetDictItem v15 v23 v10 {
      FrameState {
        NextInstrOffset 8
        Locals<3> v9 v10 v11
        Stack<2> v9 v10
      }
    }
    Return v15
  }
}
---
LoadConstRedundantConversion
---
from __static__ import box, int64

def test():
    x: int64 = 0
    return box(x)
---
fun jittestmodule:test {
  bb 0 {
    v4:Nullptr = LoadConst<Nullptr>
    v5:ImmortalLongExact[0] = LoadConst<ImmortalLongExact[0]>
    v7:OptObject = LoadGlobalCached<0; "box">
    v8:MortalFunc[function:0xdeadbeef] = GuardIs<0xdeadbeef> v7 {
      Descr 'LOAD_GLOBAL: box'
    }
    v10:Object = VectorCall<1> v8 v5 {
      FrameState {
        NextInstrOffset 10
        Locals<1> v5
      }
    }
    Return v10
  }
}
---
ArgumentsAreUnchecked
---
def test(x):
  return x
---
fun jittestmodule:test {
  bb 0 {
    v1:Object = LoadArg<0; "x">
    Return v1
  }
}
---
VariablesAreUncheckedWhenAssigned
---
def test():
  x = 1
  return x
---
fun jittestmodule:test {
  bb 0 {
    v2:Nullptr = LoadConst<Nullptr>
    v3:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    Return v3
  }
}
---
VariablesAreCheckedIfConditionallyAssigned
---
def test(x):
  if x:
    y = 1
  return y
---
fun jittestmodule:test {
  bb 0 {
    v4:Object = LoadArg<0; "x">
    v5:Nullptr = LoadConst<Nullptr>
    v7:CInt32 = IsTruthy v4 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v4 v5
      }
    }
    CondBranch<1, 2> v7
  }

  bb 1 (preds 0) {
    v8:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    Branch<2>
  }

  bb 2 (preds 0, 1) {
    v11:OptImmortalLongExact = Phi<0, 1> v5 v8
    v12:ImmortalLongExact = CheckVar<"y"> v11 {
      FrameState {
        NextInstrOffset 10
        Locals<2> v4 v11
      }
    }
    Return v12
  }
}
---
VariablesAreUncheckedIfAssignedOnAllFlows
---
def test(x):
  if x:
    y = 1
  else:
    y = 2
  return y
---
fun jittestmodule:test {
  bb 0 {
    v5:Object = LoadArg<0; "x">
    v6:Nullptr = LoadConst<Nullptr>
    v8:CInt32 = IsTruthy v5 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v5 v6
      }
    }
    CondBranch<1, 2> v8
  }

  bb 1 (preds 0) {
    v9:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    Return v9
  }

  bb 2 (preds 0) {
    v12:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    Return v12
  }
}
---
VariablesAreUncheckedOnSubgraphsWhereAssigned
---
def test(x):
  if x:
    y = 1
    if x:
      return 100
  return y
---
fun jittestmodule:test {
  bb 0 {
    v6:Object = LoadArg<0; "x">
    v7:Nullptr = LoadConst<Nullptr>
    v9:CInt32 = IsTruthy v6 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v6 v7
      }
    }
    CondBranch<1, 3> v9
  }

  bb 1 (preds 0) {
    v10:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v13:CInt32 = IsTruthy v6 {
      FrameState {
        NextInstrOffset 12
        Locals<2> v6 v10
      }
    }
    CondBranch<2, 3> v13
  }

  bb 2 (preds 1) {
    v14:ImmortalLongExact[100] = LoadConst<ImmortalLongExact[100]>
    Return v14
  }

  bb 3 (preds 0, 1) {
    v16:OptImmortalLongExact = Phi<0, 1> v7 v10
    v17:ImmortalLongExact = CheckVar<"y"> v16 {
      FrameState {
        NextInstrOffset 18
        Locals<2> v6 v16
      }
    }
    Return v17
  }
}
---
BinaryOpSubscriptFromListIsSpecialized
---
def test():
  ls = [1, 2, 3]
  return ls[1]
---
fun jittestmodule:test {
  bb 0 {
    v6:Nullptr = LoadConst<Nullptr>
    v7:MortalListExact = MakeList<0> {
      FrameState {
        NextInstrOffset 2
        Locals<1> v6
      }
    }
    v8:MortalTupleExact[tuple:0xdeadbeef] = LoadConst<MortalTupleExact[tuple:0xdeadbeef]>
    v9:NoneType = ListExtend v7 v8 {
      FrameState {
        NextInstrOffset 6
        Locals<1> v6
        Stack<1> v7
      }
    }
    v12:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    UseType<ListExact> v7
    UseType<LongExact> v12
    v18:CInt64[1] = LoadConst<CInt64[1]>
    v15:CInt64 = CheckSequenceBounds v7 v18 {
      FrameState {
        NextInstrOffset 14
        Locals<1> v7
      }
    }
    v16:CPtr = LoadField<ob_item@24, CPtr, borrowed> v7
    v17:Object = LoadArrayItem v16 v15 v7
    Return v17
  }
}
---
BinaryOpSubscriptFromNonListEmitsBinaryOp
---
# HIR
fun test {
  bb 0 {
    v0 = LoadArg<0>
    v1 = LoadConst<LongExact[1]>
    v2 = BinaryOp<Subscript> v0 v1
    Return v2
  }
}
---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v2:Object = BinaryOp<Subscript> v0 v1 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v2
  }
}
---
BinaryOpSubscriptFromTupleIsSpecialized
---
# HIR
fun test {
  bb 0 {
    v0 = LoadArg<0>
    v1 = LoadArg<1>
    v2 = RefineType<TupleExact> v0
    v3 = RefineType<LongExact> v1
    v4 = BinaryOp<Subscript> v2 v3
    Return v4
  }
}
---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:Object = LoadArg<1>
    v2:TupleExact = RefineType<TupleExact> v0
    v3:LongExact = RefineType<LongExact> v1
    UseType<TupleExact> v2
    UseType<LongExact> v3
    v5:CInt64 = PrimitiveUnbox<CInt64> v3
    v6:CInt64 = CheckSequenceBounds v2 v5 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v7:Object = LoadArrayItem<Offset[24]> v2 v6 v2
    Return v7
  }
}
---
CondBranchOfIsTruthyWithNoneRemovesCondBranch
---
# HIR
fun test {
  bb 0 {
    v0 = LoadArg<0>
    v1 = RefineType<NoneType> v0
    v2 = IsTruthy v1
    CondBranch<1, 2> v2
  }

  bb 1 {
    Return v1
  }

  bb 2 {
    Return v1
  }
}
---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:NoneType = RefineType<NoneType> v0
    UseType<NoneType> v1
    v3:CInt32[0] = LoadConst<CInt32[0]>
    Return v1
  }
}
---
CondBranchOfIsTruthyWithNoneDeletesUnreachableBlock
---
def test():
  x = None
  y = True
  if not x:
    y = False
  else:
    y = True
  return y
---
fun jittestmodule:test {
  bb 0 {
    v7:Nullptr = LoadConst<Nullptr>
    v8:NoneType = LoadConst<NoneType>
    v10:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    UseType<NoneType> v8
    v20:CInt32[0] = LoadConst<CInt32[0]>
    v17:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    Return v17
  }
}
---
CondBranchOfIsTruthyWithTrueDeletesUnreachableBlock
---
def test():
  x = True
  y = True
  if not x:
    y = False
  else:
    y = True
  return y
---
fun jittestmodule:test {
  bb 0 {
    v7:Nullptr = LoadConst<Nullptr>
    v8:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    v10:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    UseType<ImmortalBool[True]> v8
    v20:CInt32[1] = LoadConst<CInt32[1]>
    v14:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    Return v14
  }
}
---
IsTruthyWithZeroTurnsToFalse
---
def test():
  x = 0
  y = True
  if not x:
    y = False
  return y
---
fun jittestmodule:test {
  bb 0 {
    v6:Nullptr = LoadConst<Nullptr>
    v7:ImmortalLongExact[0] = LoadConst<ImmortalLongExact[0]>
    v9:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    UseType<ImmortalLongExact[0]> v7
    v18:CInt32[0] = LoadConst<CInt32[0]>
    v13:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    Return v13
  }
}
---
IsTruthyWithOneTurnsToTrue
---
def test():
  x = 1
  y = True
  if not x:
    y = False
  return y
---
fun jittestmodule:test {
  bb 0 {
    v6:Nullptr = LoadConst<Nullptr>
    v7:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v9:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    UseType<ImmortalLongExact[1]> v7
    v18:CInt32[1] = LoadConst<CInt32[1]>
    Return v9
  }
}
---
IsTruthyWithEmptyStringTurnsToFalse
---
def test():
  x = ""
  y = True
  if not x:
    y = False
  return y
---
fun jittestmodule:test {
  bb 0 {
    v6:Nullptr = LoadConst<Nullptr>
    v7:MortalUnicodeExact[""] = LoadConst<MortalUnicodeExact[""]>
    v9:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    UseType<MortalUnicodeExact[""]> v7
    v18:CInt32[0] = LoadConst<CInt32[0]>
    v13:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    Return v13
  }
}
---
IsTruthyWithNonEmptyStringTurnsToTrue
---
def test():
  x = "hello"
  y = True
  if not x:
    y = False
  return y
---
fun jittestmodule:test {
  bb 0 {
    v6:Nullptr = LoadConst<Nullptr>
    v7:MortalUnicodeExact["hello"] = LoadConst<MortalUnicodeExact["hello"]>
    v9:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    UseType<MortalUnicodeExact["hello"]> v7
    v18:CInt32[1] = LoadConst<CInt32[1]>
    Return v9
  }
}
---
LoadAttrFromTypeIsSpecialized
---
class Foo:
  pass

def test():
  return Foo.bar
---
fun jittestmodule:test {
  bb 0 {
    v2:OptObject = LoadGlobalCached<0; "Foo">
    v3:MortalTypeExact[Foo:obj] = GuardIs<0xdeadbeef> v2 {
      Descr 'LOAD_GLOBAL: Foo'
    }
    UseType<Type> v3
    v5:OptObject = LoadTypeAttrCacheItem<0, 0>
    v6:CBool = PrimitiveCompare<Equal> v5 v3
    CondBranch<1, 2> v6
  }

  bb 1 (preds 0) {
    v7:Object = LoadTypeAttrCacheItem<0, 1>
    Branch<3>
  }

  bb 2 (preds 0) {
    v8:Object = FillTypeAttrCache<0, 1> v3 {
      FrameState {
        NextInstrOffset 4
      }
    }
    Branch<3>
  }

  bb 3 (preds 1, 2) {
    v9:Object = Phi<1, 2> v7 v8
    Return v9
  }
}
---
LoadAttrFromBuiltinTypeIsSpecialized
---
def test():
  return int.__add__
---
fun jittestmodule:test {
  bb 0 {
    v2:OptObject = LoadGlobalCached<0; "int">
    v3:ImmortalTypeExact[int:obj] = GuardIs<0xdeadbeef> v2 {
      Descr 'LOAD_GLOBAL: int'
    }
    UseType<Type> v3
    v5:OptObject = LoadTypeAttrCacheItem<0, 0>
    v6:CBool = PrimitiveCompare<Equal> v5 v3
    CondBranch<1, 2> v6
  }

  bb 1 (preds 0) {
    v7:Object = LoadTypeAttrCacheItem<0, 1>
    Branch<3>
  }

  bb 2 (preds 0) {
    v8:Object = FillTypeAttrCache<0, 1> v3 {
      FrameState {
        NextInstrOffset 4
      }
    }
    Branch<3>
  }

  bb 3 (preds 1, 2) {
    v9:Object = Phi<1, 2> v7 v8
    Return v9
  }
}
---
LoadAttrFromModuleIsUnspecialized
---
import sys

def test():
  return sys.path
---
fun jittestmodule:test {
  bb 0 {
    v2:OptObject = LoadGlobalCached<0; "sys">
    v3:MortalObjectUser[module:0xdeadbeef] = GuardIs<0xdeadbeef> v2 {
      Descr 'LOAD_GLOBAL: sys'
    }
    v4:Object = LoadAttr<1; "path"> v3 {
      FrameState {
        NextInstrOffset 4
      }
    }
    Return v4
  }
}
---
RedundantGuardTypeIsRemoved
---
# HIR
fun test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = RefineType<TupleExact> v1
    v3 = GuardType<Tuple> v2
    Return v3
  }
}
---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:TupleExact = RefineType<TupleExact> v1
    Return v2
  }
}
---
CompareOfTwoNonesTurnsToLoadConst
---
# HIR
fun test {
  bb 0 {
    v0:Object = LoadArg<0; "x">
    v1:Object = LoadConst<NoneType>
    v2:NoneType = GuardType<NoneType> v0
    v3:Object = Compare<Equal> v1 v2
    v4:CInt32 = IsTruthy v3 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v2 v1
      }
    }
    CondBranch<2, 1> v4
  }

  bb 1 (preds 0) {
    v5:NoneType = LoadConst<NoneType>
    Branch<2>
  }

  bb 2 (preds 0, 1) {
    v7:Object = Phi<0, 1> v1 v5
    Return v7
  }
}
---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:NoneType = LoadConst<NoneType>
    v8:NoneType = GuardIs<0xdeadbeef> v0 {
    }
    UseType<NoneType> v1
    UseType<NoneType> v8
    v9:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    UseType<ImmortalBool[True]> v9
    v10:CInt32[1] = LoadConst<CInt32[1]>
    Return v1
  }
}
---
CompareIsOfNonEqualTypesTurnsToLoadConst
---
def test():
  x = 2
  if x is None:
    return True
  return False
---
fun jittestmodule:test {
  bb 0 {
    v7:Nullptr = LoadConst<Nullptr>
    v8:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v11:NoneType = LoadConst<NoneType>
    UseType<ImmortalLongExact[2]> v8
    UseType<NoneType> v11
    v16:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    UseType<ImmortalBool[False]> v16
    v17:CInt32[0] = LoadConst<CInt32[0]>
    v15:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    Return v15
  }
}
---
CompareIsOfKnownObjectsTurnsToLoadConst
---
def test():
  x = 2
  y = 4
  if x is y:
    return True
  return False
---
fun jittestmodule:test {
  bb 0 {
    v8:Nullptr = LoadConst<Nullptr>
    v9:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v11:ImmortalLongExact[4] = LoadConst<ImmortalLongExact[4]>
    UseType<ImmortalLongExact[2]> v9
    UseType<ImmortalLongExact[4]> v11
    v19:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    UseType<ImmortalBool[False]> v19
    v20:CInt32[0] = LoadConst<CInt32[0]>
    v18:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    Return v18
  }
}
---
CompareOfTwoLongsTurnsToLongCompare
---
# HIR
fun test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v1 = LoadArg<1; "y">
    v2 = GuardType<LongExact> v0
    v3 = GuardType<LongExact> v1
    v4 = Compare<Equal> v2 v3
    v5 = IsTruthy v4 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v2 v3
      }
    }
    CondBranch<2, 1> v5
  }

  bb 1 (preds 0) {
    v6 = LoadConst<ImmortalBool[True]>
    Return v6
  }

  bb 2 (preds 0) {
    v7 = LoadConst<ImmortalBool[False]>
    Return v7
  }
}
---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:Object = LoadArg<1>
    v2:LongExact = GuardType<LongExact> v0 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v3:LongExact = GuardType<LongExact> v1 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v8:Bool = LongCompare<Equal> v2 v3
    UseType<Bool> v8
    v9:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    v10:CBool = PrimitiveCompare<Equal> v8 v9
    v11:CInt32 = IntConvert<CInt32> v10
    CondBranch<2, 1> v11
  }

  bb 2 (preds 0) {
    v7:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    Return v7
  }

  bb 1 (preds 0) {
    v6:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    Return v6
  }
}
---
CompareOfTwoStringsTurnsToUnicodeCompare
---
# HIR
fun test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v1 = LoadArg<1; "y">
    v2 = GuardType<UnicodeExact> v0
    v3 = GuardType<UnicodeExact> v1
    v4 = Compare<Equal> v2 v3
    v5 = IsTruthy v4 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v2 v3
      }
    }
    CondBranch<2, 1> v5
  }

  bb 1 (preds 0) {
    v6 = LoadConst<ImmortalBool[True]>
    Return v6
  }

  bb 2 (preds 0) {
    v7 = LoadConst<ImmortalBool[False]>
    Return v7
  }
}
---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:Object = LoadArg<1>
    v2:UnicodeExact = GuardType<UnicodeExact> v0 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v3:UnicodeExact = GuardType<UnicodeExact> v1 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v8:Bool = UnicodeCompare<Equal> v2 v3
    UseType<Bool> v8
    v9:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    v10:CBool = PrimitiveCompare<Equal> v8 v9
    v11:CInt32 = IntConvert<CInt32> v10
    CondBranch<2, 1> v11
  }

  bb 2 (preds 0) {
    v7:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    Return v7
  }

  bb 1 (preds 0) {
    v6:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    Return v6
  }
}
---
CondBranchCheckTypeWithKnownTypeTransformsToBranch
---
# HIR
fun test {
  bb 0 {
    v0 = LoadArg<0>
    v1 = RefineType<TupleExact> v0
    CondBranchCheckType<1, 2, Tuple> v1
  }

  bb 1 {
    v2 = LoadConst<NoneType>
    Return v2
  }

  bb 2 {
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:TupleExact = RefineType<TupleExact> v0
    UseType<TupleExact> v1
    v2:NoneType = LoadConst<NoneType>
    Return v2
  }
}
---
CondBranchCheckTypeWithKnownIncompatibleTypeTransformsToBranch
---
# HIR
fun test {
  bb 0 {
    v0 = LoadArg<0>
    v1 = RefineType<NoneType> v0
    CondBranchCheckType<1, 2, Tuple> v1
  }

  bb 1 {
    v2 = LoadConst<NoneType>
    Return v2
  }

  bb 2 {
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:NoneType = RefineType<NoneType> v0
    UseType<NoneType> v1
    v3:NoneType = LoadConst<NoneType>
    Return v3
  }
}
---
CondBranchCheckTypeWithNoTypeInformationDoesNotTransform
---
# HIR
fun test {
  bb 0 {
    v0 = LoadArg<0>
    CondBranchCheckType<1, 2, Tuple> v0
  }

  bb 1 {
    v2 = LoadConst<NoneType>
    Return v2
  }

  bb 2 {
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    CondBranchCheckType<1, 2, Tuple> v0
  }

  bb 1 (preds 0) {
    v2:NoneType = LoadConst<NoneType>
    Return v2
  }

  bb 2 (preds 0) {
    v3:NoneType = LoadConst<NoneType>
    Return v3
  }
}
---
IsTruthyWithObjectRemainsIsTruthy
---
# HIR
fun test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = Assign v1
    v3 = IsTruthy v2
    v4 = PrimitiveBox<CInt32> v3
    Return v4
  }
}
---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Object = Assign v1
    v3:CInt32 = IsTruthy v2 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v4:LongExact = PrimitiveBox<CInt32> v3 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
---
IsTruthyWithBoolRewritesToPrimitiveCompare
---
# HIR
fun test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = RefineType<Bool> v1
    v3 = IsTruthy v2
    v4 = PrimitiveBox<CInt32> v3
    Return v4
  }
}
---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Bool = RefineType<Bool> v1
    UseType<Bool> v2
    v5:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    v6:CBool = PrimitiveCompare<Equal> v2 v5
    v7:CInt32 = IntConvert<CInt32> v6
    v4:LongExact = PrimitiveBox<CInt32> v7 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
---
IsTruthyWithListExactRewritesToLoadField
---
# HIR
fun test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = RefineType<ListExact> v1
    v3 = IsTruthy v2
    v4 = PrimitiveBox<CInt32> v3
    Return v4
  }
}
---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:ListExact = RefineType<ListExact> v1
    UseType<ListExact> v2
    v5:CInt64 = LoadField<ob_size@16, CInt64, borrowed> v2
    v6:CInt32 = IntConvert<CInt32> v5
    v4:LongExact = PrimitiveBox<CInt32> v6 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
---
IsTruthyWithListExactWithObjSpecRewritesToLoadField
---
a = [1,2,3]
def test():
  if a:
    return 1
  return 2
---
fun jittestmodule:test {
  bb 0 {
    v4:OptObject = LoadGlobalCached<0; "a">
    v5:MortalListExact[list:0xdeadbeef] = GuardIs<0xdeadbeef> v4 {
      Descr 'LOAD_GLOBAL: a'
    }
    UseType<MortalListExact> v5
    v9:CInt64 = LoadField<ob_size@16, CInt64, borrowed> v5
    v10:CInt32 = IntConvert<CInt32> v9
    CondBranch<1, 2> v10
  }

  bb 1 (preds 0) {
    v7:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    Return v7
  }

  bb 2 (preds 0) {
    v8:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    Return v8
  }
}
---
IsTruthyWithTupleExactRewritesToLoadField
---
# HIR
fun test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = RefineType<TupleExact> v1
    v3 = IsTruthy v2
    v4 = PrimitiveBox<CInt32> v3
    Return v4
  }
}
---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:TupleExact = RefineType<TupleExact> v1
    UseType<TupleExact> v2
    v5:CInt64 = LoadField<ob_size@16, CInt64, borrowed> v2
    v6:CInt32 = IntConvert<CInt32> v5
    v4:LongExact = PrimitiveBox<CInt32> v6 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
---
IsTruthyWithArrayExactRewritesToLoadField
---
# HIR
fun test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = RefineType<Array> v1
    v3 = IsTruthy v2
    v4 = PrimitiveBox<CInt32> v3
    Return v4
  }
}
---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Array = RefineType<Array> v1
    UseType<Array> v2
    v5:CInt64 = LoadField<ob_size@16, CInt64, borrowed> v2
    v6:CInt32 = IntConvert<CInt32> v5
    v4:LongExact = PrimitiveBox<CInt32> v6 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
---
IsTruthyWithDictExactRewritesToLoadField
---
# HIR
fun test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = RefineType<DictExact> v1
    v3 = IsTruthy v2
    v4 = PrimitiveBox<CInt32> v3
    Return v4
  }
}
---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:DictExact = RefineType<DictExact> v1
    UseType<DictExact> v2
    v5:CInt64 = LoadField<ma_used@16, CInt64, borrowed> v2
    v6:CInt32 = IntConvert<CInt32> v5
    v4:LongExact = PrimitiveBox<CInt32> v6 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
---
IsTruthyWithSetExactRewritesToLoadField
---
# HIR
fun test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = RefineType<SetExact> v1
    v3 = IsTruthy v2
    v4 = PrimitiveBox<CInt32> v3
    Return v4
  }
}
---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:SetExact = RefineType<SetExact> v1
    UseType<SetExact> v2
    v5:CInt64 = LoadField<used@24, CInt64, borrowed> v2
    v6:CInt32 = IntConvert<CInt32> v5
    v4:LongExact = PrimitiveBox<CInt32> v6 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
---
IsTruthyWithUnicodeExactRewritesToLoadField
---
# HIR
fun test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = RefineType<UnicodeExact> v1
    v3 = IsTruthy v2
    v4 = PrimitiveBox<CInt32> v3
    Return v4
  }
}
---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:UnicodeExact = RefineType<UnicodeExact> v1
    UseType<UnicodeExact> v2
    v5:CInt64 = LoadField<length@16, CInt64, borrowed> v2
    v6:CInt32 = IntConvert<CInt32> v5
    v4:LongExact = PrimitiveBox<CInt32> v6 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
---
IsTruthyWithLongExactRewritesToPrimitiveCompare
---
# HIR
fun test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = RefineType<LongExact> v1
    v3 = IsTruthy v2
    v4 = PrimitiveBox<CInt32> v3
    Return v4
  }
}
---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:LongExact = RefineType<LongExact> v1
    UseType<LongExact> v2
    v5:ImmortalLongExact[0] = LoadConst<ImmortalLongExact[0]>
    v6:CBool = PrimitiveCompare<NotEqual> v2 v5
    v7:CInt32 = IntConvert<CInt32> v6
    v4:LongExact = PrimitiveBox<CInt32> v7 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
---
TypeIsTurnedIntoFieldLoad
---
def test(x):
  return type(x)
---
fun jittestmodule:test {
  bb 0 {
    v3:Object = LoadArg<0; "x">
    v4:OptObject = LoadGlobalCached<0; "type">
    v5:ImmortalTypeExact[type:obj] = GuardIs<0xdeadbeef> v4 {
      Descr 'LOAD_GLOBAL: type'
    }
    UseType<ImmortalTypeExact[type:obj]> v5
    v8:Type = LoadField<ob_type@8, Type, borrowed> v3
    Return v8
  }
}
---
BinaryOpWithLeftAndRightLongExactTurnsIntoLongBinaryOp
---
# HIR
fun test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = LoadArg<1>
    v3 = RefineType<LongExact> v1
    v4 = RefineType<LongExact> v2
    v5 = BinaryOp<Add> v3 v4
    Return v5
  }
}
---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Object = LoadArg<1>
    v3:LongExact = RefineType<LongExact> v1
    v4:LongExact = RefineType<LongExact> v2
    UseType<LongExact> v3
    UseType<LongExact> v4
    v6:LongExact = LongBinaryOp<Add> v3 v4 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v6
  }
}
---
BinaryOpWithObjSpecLeftAndRightLongExactTurnsIntoLoadConst
---
# HIR
fun test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = LoadArg<1>
    v3 = RefineType<LongExact[2]> v1
    v4 = RefineType<LongExact[3]> v2
    v5 = BinaryOp<Power> v3 v4
    Return v5
  }
}
---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Object = LoadArg<1>
    v3:ImmortalLongExact[2] = RefineType<ImmortalLongExact[2]> v1
    v4:ImmortalLongExact[3] = RefineType<ImmortalLongExact[3]> v2
    UseType<LongExact> v3
    UseType<LongExact> v4
    UseType<ImmortalLongExact[2]> v3
    UseType<ImmortalLongExact[3]> v4
    v7:ImmortalLongExact[8] = LoadConst<ImmortalLongExact[8]>
    Return v7
  }
}
---
BinaryOpTrueDivideWithLeftAndRightLongExactTurnsIntoLongBinaryOpFloat
---
# HIR
fun test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = LoadArg<1>
    v3 = RefineType<LongExact> v1
    v4 = RefineType<LongExact> v2
    v5 = BinaryOp<TrueDivide> v3 v4
    Return v5
  }
}
---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Object = LoadArg<1>
    v3:LongExact = RefineType<LongExact> v1
    v4:LongExact = RefineType<LongExact> v2
    UseType<LongExact> v3
    UseType<LongExact> v4
    v6:FloatExact = LongBinaryOp<TrueDivide> v3 v4 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v6
  }
}
---
BinarySubscrWithConstTupleAndObjectSpecIndexSimplifiesToLoadConst
---
def test():
  tup = (1,(2,3,4),5)
  return tup[1][2]
---
fun jittestmodule:test {
  bb 0 {
    v6:Nullptr = LoadConst<Nullptr>
    v7:MortalTupleExact[tuple:0xdeadbeef] = LoadConst<MortalTupleExact[tuple:0xdeadbeef]>
    v10:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    UseType<MortalTupleExact[tuple:0xdeadbeef]> v7
    UseType<ImmortalLongExact[1]> v10
    v14:MortalTupleExact[tuple:0xdeadbeef] = LoadConst<MortalTupleExact[tuple:0xdeadbeef]>
    v12:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    UseType<MortalTupleExact[tuple:0xdeadbeef]> v14
    UseType<ImmortalLongExact[2]> v12
    v15:ImmortalLongExact[4] = LoadConst<ImmortalLongExact[4]>
    Return v15
  }
}
---
IsBecomesComparisonOutsideIf
---
def test(x, y):
  return x is y
---
fun jittestmodule:test {
  bb 0 {
    v3:Object = LoadArg<0; "x">
    v4:Object = LoadArg<1; "y">
    v8:CBool = PrimitiveCompare<Equal> v3 v4
    v9:Bool = PrimitiveBoxBool v8
    Return v9
  }
}
---
IsNotBecomesComparisonOutsideIf
---
def test(x, y):
  return x is not y
---
fun jittestmodule:test {
  bb 0 {
    v3:Object = LoadArg<0; "x">
    v4:Object = LoadArg<1; "y">
    v8:CBool = PrimitiveCompare<NotEqual> v3 v4
    v9:Bool = PrimitiveBoxBool v8
    Return v9
  }
}
---
DontSpecializeLongSubscript
---
# HIR
fun jittestmodule:test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = LoadArg<1>
    v3 = RefineType<LongExact> v1
    v4 = RefineType<LongExact> v2
    v5 = BinaryOp<Subscript> v3 v4
    Return v5
  }
}
---
fun jittestmodule:test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Object = LoadArg<1>
    v3:LongExact = RefineType<LongExact> v1
    v4:LongExact = RefineType<LongExact> v2
    v5:Object = BinaryOp<Subscript> v3 v4 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v5
  }
}
---
UnicodeConcatEmittedWhenWhenAddingString
---
def test():
  x = "hello"
  y = " world"
  return x+y
---
fun jittestmodule:test {
  bb 0 {
    v5:Nullptr = LoadConst<Nullptr>
    v6:MortalUnicodeExact["hello"] = LoadConst<MortalUnicodeExact["hello"]>
    v8:MortalUnicodeExact[" world"] = LoadConst<MortalUnicodeExact[" world"]>
    v13:UnicodeExact = UnicodeConcat v6 v8 {
      FrameState {
        NextInstrOffset 14
        Locals<2> v6 v8
      }
    }
    Return v13
  }
}
---
UnicodeConcatDoesNotEmitWhenStringAddingLong
---
def test():
  x = "hello"
  y = 1
  return x+y
---
fun jittestmodule:test {
  bb 0 {
    v5:Nullptr = LoadConst<Nullptr>
    v6:MortalUnicodeExact["hello"] = LoadConst<MortalUnicodeExact["hello"]>
    v8:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v12:Object = BinaryOp<Add> v6 v8 {
      FrameState {
        NextInstrOffset 14
        Locals<2> v6 v8
      }
    }
    Return v12
  }
}
---
UnicodeConcatEmittedWhenSimplyfingAddingTwoUnicode
---
# HIR
fun test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = LoadArg<1>
    v3 = RefineType<UnicodeExact> v1
    v4 = RefineType<UnicodeExact> v2
    v5:UnicodeExact = BinaryOp<Add> v3 v4
    Return v5
  }
}
---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Object = LoadArg<1>
    v3:UnicodeExact = RefineType<UnicodeExact> v1
    v4:UnicodeExact = RefineType<UnicodeExact> v2
    v6:UnicodeExact = UnicodeConcat v3 v4 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v6
  }
}
---
UnicodeRepeatEmittedWhenMultiplyingString
---
def test():
  a = "abc"
  b = 2
  return a*b
---
fun jittestmodule:test {
  bb 0 {
    v5:Nullptr = LoadConst<Nullptr>
    v6:MortalUnicodeExact["abc"] = LoadConst<MortalUnicodeExact["abc"]>
    v8:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v16:CInt64[2] = LoadConst<CInt64[2]>
    v17:CInt64[0] = LoadConst<CInt64[0]>
    v15:UnicodeExact = UnicodeRepeat v6 v16 {
      FrameState {
        NextInstrOffset 14
        Locals<2> v6 v8
      }
    }
    Return v15
  }
}
---
UnicodeRepeatDoesNotEmitWhenStringMultipliedByNonLongExact
---
def test():
  a = "abc"
  b = True
  return a*b
---
fun jittestmodule:test {
  bb 0 {
    v5:Nullptr = LoadConst<Nullptr>
    v6:MortalUnicodeExact["abc"] = LoadConst<MortalUnicodeExact["abc"]>
    v8:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    v12:Object = BinaryOp<Multiply> v6 v8 {
      FrameState {
        NextInstrOffset 14
        Locals<2> v6 v8
      }
    }
    Return v12
  }
}
---
UnicodeRepeatEmittedWhenSimplyfingMultiplyWithNonConstLongExact
---
# HIR
fun test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = LoadArg<1>
    v3 = RefineType<UnicodeExact> v1
    v4 = RefineType<LongExact> v2
    v5:UnicodeExact = BinaryOp<Multiply> v3 v4
    Return v5
  }
}
---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Object = LoadArg<1>
    v3:UnicodeExact = RefineType<UnicodeExact> v1
    v4:LongExact = RefineType<LongExact> v2
    v6:CInt64 = PrimitiveUnbox<CInt64> v4
    v7:CInt64 = IsNegativeAndErrOccurred v6 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v8:UnicodeExact = UnicodeRepeat v3 v6 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v8
  }
}
---
BinarySubscrWithDictExactAndUnicodeExactEmitsDictSubscr
---
# HIR
fun jittestmodule:test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = LoadArg<1>
    v3 = RefineType<DictExact> v1
    v4 = RefineType<UnicodeExact> v2
    v5 = BinaryOp<Subscript> v3 v4
    Return v5
  }
}
---
fun jittestmodule:test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Object = LoadArg<1>
    v3:DictExact = RefineType<DictExact> v1
    v4:UnicodeExact = RefineType<UnicodeExact> v2
    v6:Object = DictSubscr v3 v4 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v6
  }
}
---
BinarySubscrWithDictExactAndLongExactEmitsDictSubscr
---
# HIR
fun jittestmodule:test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = LoadArg<1>
    v3 = RefineType<DictExact> v1
    v4 = RefineType<LongExact> v2
    v5 = BinaryOp<Subscript> v3 v4
    Return v5
  }
}
---
fun jittestmodule:test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Object = LoadArg<1>
    v3:DictExact = RefineType<DictExact> v1
    v4:LongExact = RefineType<LongExact> v2
    v6:Object = DictSubscr v3 v4 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v6
  }
}
---
BinarySubscrWithDictExactAndDictExactEmitsDictSubscr
---
# HIR
fun jittestmodule:test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = LoadArg<1>
    v3 = RefineType<DictExact> v1
    v4 = RefineType<DictExact> v2
    v5 = BinaryOp<Subscript> v3 v4
    Return v5
  }
}
---
fun jittestmodule:test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Object = LoadArg<1>
    v3:DictExact = RefineType<DictExact> v1
    v4:DictExact = RefineType<DictExact> v2
    v6:Object = DictSubscr v3 v4 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v6
  }
}
---
GuardIsReturnsIntersectionOfInputAndTarget
---
# HIR
fun jittestmodule:test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = GuardType<LongExact> v1
    v3 = GuardType<NoneType> v2
    Return v3
  }
}
---
fun jittestmodule:test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:LongExact = GuardType<LongExact> v1 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v4:Bottom = GuardIs<0xdeadbeef> v2 {
    }
    Unreachable
  }
}
---
CompareOfBoxedBoolToTrueSimplifiedToOriginalBool
---
# HIR
fun test {
  bb 0 {
    v0 = LoadArg<0, CBool>
    v1 = PrimitiveBoxBool v0
    v2 = LoadConst<Bool[True]>
    v3 = PrimitiveCompare<Equal> v1 v2
    Return<CBool> v3
  }
}
---
fun test {
  bb 0 {
    v0:CBool = LoadArg<0, CBool>
    v1:Bool = PrimitiveBoxBool v0
    v2:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    Return<CBool> v0
  }
}
---
BooleanNotTurnsIntoPrimitive
---
# HIR
fun jittestmodule:test {
  bb 0 {
    v1 = LoadArg<0; "x", Bool>
    v2 = UnaryOp<Not> v1
    Return v2
  }
}
---
fun jittestmodule:test {
  bb 0 {
    v1:Bool = LoadArg<0, Bool>
    UseType<Bool> v1
    v3:CBool = PrimitiveUnbox<CBool> v1
    v4:CBool = PrimitiveUnaryOp<NotInt> v3
    v5:Bool = PrimitiveBoxBool v4
    Return v5
  }
}
---
GetLengthWithListTurnsIntoLoadField
---
# HIR
fun test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = RefineType<ListExact> v0
    v2 = GetLength v1
    Return v2
  }
}
---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:ListExact = RefineType<ListExact> v0
    UseType<ListExact> v1
    v3:CInt64 = LoadField<ob_size@16, CInt64, borrowed> v1
    v4:LongExact = PrimitiveBox<CInt64> v3 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
---
GetLengthWithTupleTurnsIntoLoadField
---
# HIR
fun test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = RefineType<TupleExact> v0
    v2 = GetLength v1
    Return v2
  }
}
---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:TupleExact = RefineType<TupleExact> v0
    UseType<TupleExact> v1
    v3:CInt64 = LoadField<ob_size@16, CInt64, borrowed> v1
    v4:LongExact = PrimitiveBox<CInt64> v3 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
---
GetLengthWithUnknownRemainsGetLength
---
# HIR
fun test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = GetLength v0
    Return v1
  }
}
---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:LongExact = GetLength v0 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v1
  }
}
---
CheckSequenceBoundsWithKnownInBoundsIndexEliminated
---
# HIR
fun test {
  bb 0 {
    v0 = LoadConst<CInt64[63]>
    v1 = MakeTuple<1> v0
    v2 = LoadConst<CInt64[0]>
    v3 = CheckSequenceBounds v1 v2
    Return<CInt64> v3
  }
}
---
fun test {
  bb 0 {
    v0:CInt64[63] = LoadConst<CInt64[63]>
    v1:MortalTupleExact = MakeTuple<1> v0 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v2:CInt64[0] = LoadConst<CInt64[0]>
    UseType<MortalTupleExact> v1
    UseType<CInt64[0]> v2
    Return<CInt64> v2
  }
}
---
CheckSequenceBoundsWithKnownInBoundsNegativeIndexEliminated
---
# HIR
fun test {
  bb 0 {
    v0 = LoadConst<CInt64[63]>
    v1 = MakeTuple<1> v0
    v2 = LoadConst<CInt64[-1]>
    v3 = CheckSequenceBounds v1 v2
    Return<CInt64> v3
  }
}
---
fun test {
  bb 0 {
    v0:CInt64[63] = LoadConst<CInt64[63]>
    v1:MortalTupleExact = MakeTuple<1> v0 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v2:CInt64[-1] = LoadConst<CInt64[-1]>
    UseType<MortalTupleExact> v1
    UseType<CInt64[-1]> v2
    v4:CInt64[0] = LoadConst<CInt64[0]>
    Return<CInt64> v4
  }
}
---
CheckSequenceBoundsWithKnownOutOfBoundsIndexNotEliminated
---
# HIR
fun test {
  bb 0 {
    v0 = LoadConst<CInt64[63]>
    v1 = MakeTuple<1> v0
    v2 = LoadConst<CInt64[1]>
    v3 = CheckSequenceBounds v1 v2
    Return<CInt64> v3
  }
}
---
fun test {
  bb 0 {
    v0:CInt64[63] = LoadConst<CInt64[63]>
    v1:MortalTupleExact = MakeTuple<1> v0 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v2:CInt64[1] = LoadConst<CInt64[1]>
    v3:CInt64 = CheckSequenceBounds v1 v2 {
    }
    Return<CInt64> v3
  }
}
---
LoadArrayItemWithInBoundsIndexIntoMakeListTupleReachesThroughIt
---
def test(x, y, z):
  t = (x, y, z)
  return t[1]
---
fun jittestmodule:test {
  bb 0 {
    v7:Object = LoadArg<0; "x">
    v8:Object = LoadArg<1; "y">
    v9:Object = LoadArg<2; "z">
    v10:Nullptr = LoadConst<Nullptr>
    v14:MortalTupleExact = MakeTuple<3> v7 v8 v9 {
      FrameState {
        NextInstrOffset 8
        Locals<4> v7 v8 v9 v10
        Stack<3> v7 v8 v9
      }
    }
    v17:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    UseType<TupleExact> v14
    UseType<LongExact> v17
    v22:CInt64[1] = LoadConst<CInt64[1]>
    UseType<MortalTupleExact> v14
    UseType<CInt64[1]> v22
    UseType<TupleExact> v14
    UseType<CInt64[1]> v22
    Return v8
  }
}
---
LoadArrayItemWithTooBigIndexIntoMakeListTupleKeepsLoadArrayItem
---
def test(x, y, z):
  t = (x, y, z)
  return t[3]
---
fun jittestmodule:test {
  bb 0 {
    v7:Object = LoadArg<0; "x">
    v8:Object = LoadArg<1; "y">
    v9:Object = LoadArg<2; "z">
    v10:Nullptr = LoadConst<Nullptr>
    v14:MortalTupleExact = MakeTuple<3> v7 v8 v9 {
      FrameState {
        NextInstrOffset 8
        Locals<4> v7 v8 v9 v10
        Stack<3> v7 v8 v9
      }
    }
    v17:ImmortalLongExact[3] = LoadConst<ImmortalLongExact[3]>
    UseType<TupleExact> v14
    UseType<LongExact> v17
    v22:CInt64[3] = LoadConst<CInt64[3]>
    v20:CInt64 = CheckSequenceBounds v14 v22 {
      FrameState {
        NextInstrOffset 16
        Locals<4> v7 v8 v9 v14
      }
    }
    v21:Object = LoadArrayItem<Offset[24]> v14 v20 v14
    Return v21
  }
}
---
UnpackSequenceWithCorrectNumberOfValuesReachesThroughAllocation
---
def test(x, y, z):
  a, b, c = (x, y, z)
  return b
---
fun jittestmodule:test {
  bb 0 {
    v6:Object = LoadArg<0; "x">
    v7:Object = LoadArg<1; "y">
    v8:Object = LoadArg<2; "z">
    v9:Nullptr = LoadConst<Nullptr>
    Return v7
  }
}
---
UnpackSequenceWithIncorrectNumberOfValuesKeepsAllocation
---
def test(x, y, z):
  a, c = (x, y, z)
  return a
---
fun jittestmodule:test {
  bb 0 {
    v14:Object = LoadArg<0; "x">
    v15:Object = LoadArg<1; "y">
    v16:Object = LoadArg<2; "z">
    v17:Nullptr = LoadConst<Nullptr>
    v21:MortalTupleExact = MakeTuple<3> v14 v15 v16 {
      FrameState {
        NextInstrOffset 8
        Locals<5> v14 v15 v16 v17 v17
        Stack<3> v14 v15 v16
      }
    }
    UseType<MortalTupleExact> v21
    v22:CInt64[24] = LoadConst<CInt64[24]>
    v23:CPtr = LoadFieldAddress v21 v22
    UseType<MortalTupleExact> v21
    v48:CInt64[3] = LoadConst<CInt64[3]>
    v27:CInt64[2] = LoadConst<CInt64[2]>
    UseType<CInt64[3]> v48
    UseType<CInt64[2]> v27
    v49:CBool[false] = LoadConst<CBool[false]>
    Deopt {
      Descr 'UNPACK_SEQUENCE'
      GuiltyReg v21
    }
  }
}
---
LoadVarObjectSizeWithConstTupleEmitsLoadConst
---
def test():
  a, b, c = (1,2,3)
  return a
---
fun jittestmodule:test {
  bb 0 {
    v13:Nullptr = LoadConst<Nullptr>
    v14:MortalTupleExact[tuple:0xdeadbeef] = LoadConst<MortalTupleExact[tuple:0xdeadbeef]>
    UseType<MortalTupleExact[tuple:0xdeadbeef]> v14
    v15:CInt64[24] = LoadConst<CInt64[24]>
    v16:CPtr = LoadFieldAddress v14 v15
    UseType<MortalTupleExact[tuple:0xdeadbeef]> v14
    v40:CInt64[3] = LoadConst<CInt64[3]>
    v20:CInt64[3] = LoadConst<CInt64[3]>
    UseType<CInt64[3]> v40
    UseType<CInt64[3]> v20
    v41:CBool[true] = LoadConst<CBool[true]>
    v22:CInt64[2] = LoadConst<CInt64[2]>
    UseType<MortalTupleExact[tuple:0xdeadbeef]> v14
    UseType<CInt64[2]> v22
    v42:ImmortalLongExact[3] = LoadConst<ImmortalLongExact[3]>
    v25:CInt64[1] = LoadConst<CInt64[1]>
    UseType<MortalTupleExact[tuple:0xdeadbeef]> v14
    UseType<CInt64[1]> v25
    v43:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v27:CInt64[0] = LoadConst<CInt64[0]>
    UseType<MortalTupleExact[tuple:0xdeadbeef]> v14
    UseType<CInt64[0]> v27
    v44:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    Return v44
  }
}
---
PrimitiveBoxWithTrueEmitsLoadConstTrue
---
# HIR
fun jittestmodule:test {
  bb 0 {
    v0 = LoadConst<CBool[true]>
    v1 = PrimitiveBoxBool v0
    Return v1
  }
}
---
fun jittestmodule:test {
  bb 0 {
    v0:CBool[true] = LoadConst<CBool[true]>
    UseType<CBool[true]> v0
    v2:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    Return v2
  }
}
---
PrimitiveBoxWithFalseEmitsLoadConstFalse
---
# HIR
fun jittestmodule:test {
  bb 0 {
    v0 = LoadConst<CBool[false]>
    v1 = PrimitiveBoxBool v0
    Return v1
  }
}
---
fun jittestmodule:test {
  bb 0 {
    v0:CBool[false] = LoadConst<CBool[false]>
    UseType<CBool[false]> v0
    v2:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    Return v2
  }
}
---
PrimitiveCompareEqualWithEqualInputsEmitsLoadConstTrue
---
# HIR
fun jittestmodule:test {
  bb 0 {
    v0 = LoadConst<CInt32[123]>
    v1 = LoadConst<CInt32[123]>
    v2 = PrimitiveCompare<Equal> v0 v1
    v3 = PrimitiveBoxBool v2
    Return v3
  }
}
---
fun jittestmodule:test {
  bb 0 {
    v0:CInt32[123] = LoadConst<CInt32[123]>
    v1:CInt32[123] = LoadConst<CInt32[123]>
    UseType<CInt32[123]> v0
    UseType<CInt32[123]> v1
    v4:CBool[true] = LoadConst<CBool[true]>
    UseType<CBool[true]> v4
    v5:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    Return v5
  }
}
---
PrimitiveCompareEqualWithInequalInputsEmitsLoadConstFalse
---
# HIR
fun jittestmodule:test {
  bb 0 {
    v0 = LoadConst<CInt32[123]>
    v1 = LoadConst<CInt32[456]>
    v2 = PrimitiveCompare<Equal> v0 v1
    v3 = PrimitiveBoxBool v2
    Return v3
  }
}
---
fun jittestmodule:test {
  bb 0 {
    v0:CInt32[123] = LoadConst<CInt32[123]>
    v1:CInt32[456] = LoadConst<CInt32[456]>
    UseType<CInt32[123]> v0
    UseType<CInt32[456]> v1
    v4:CBool[false] = LoadConst<CBool[false]>
    UseType<CBool[false]> v4
    v5:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    Return v5
  }
}
---
PrimitiveCompareEqualWithUnknownInputsDoesNotSimplify
---
# HIR
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x", CInt32>
    v1 = LoadConst<CInt32[123]>
    v2 = PrimitiveCompare<Equal> v0 v1
    v3 = PrimitiveBoxBool v2
    Return v3
  }
}
---
fun jittestmodule:test {
  bb 0 {
    v0:CInt32 = LoadArg<0, CInt32>
    v1:CInt32[123] = LoadConst<CInt32[123]>
    v2:CBool = PrimitiveCompare<Equal> v0 v1
    v3:Bool = PrimitiveBoxBool v2
    Return v3
  }
}
---
PrimitiveCompareNotEqualWithEqualInputsEmitsLoadConstFalse
---
# HIR
fun jittestmodule:test {
  bb 0 {
    v0 = LoadConst<CInt32[123]>
    v1 = LoadConst<CInt32[123]>
    v2 = PrimitiveCompare<NotEqual> v0 v1
    v3 = PrimitiveBoxBool v2
    Return v3
  }
}
---
fun jittestmodule:test {
  bb 0 {
    v0:CInt32[123] = LoadConst<CInt32[123]>
    v1:CInt32[123] = LoadConst<CInt32[123]>
    UseType<CInt32[123]> v0
    UseType<CInt32[123]> v1
    v4:CBool[false] = LoadConst<CBool[false]>
    UseType<CBool[false]> v4
    v5:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    Return v5
  }
}
---
PrimitiveCompareNotEqualWithInequalInputsEmitsLoadConstTrue
---
# HIR
fun jittestmodule:test {
  bb 0 {
    v0 = LoadConst<CInt32[123]>
    v1 = LoadConst<CInt32[456]>
    v2 = PrimitiveCompare<NotEqual> v0 v1
    v3 = PrimitiveBoxBool v2
    Return v3
  }
}
---
fun jittestmodule:test {
  bb 0 {
    v0:CInt32[123] = LoadConst<CInt32[123]>
    v1:CInt32[456] = LoadConst<CInt32[456]>
    UseType<CInt32[123]> v0
    UseType<CInt32[456]> v1
    v4:CBool[true] = LoadConst<CBool[true]>
    UseType<CBool[true]> v4
    v5:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    Return v5
  }
}
---
PrimitiveCompareNotEqualWithUnknownInputsDoesNotSimplify
---
# HIR
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x", CInt32>
    v1 = LoadConst<CInt32[123]>
    v2 = PrimitiveCompare<NotEqual> v0 v1
    v3 = PrimitiveBoxBool v2
    Return v3
  }
}
---
fun jittestmodule:test {
  bb 0 {
    v0:CInt32 = LoadArg<0, CInt32>
    v1:CInt32[123] = LoadConst<CInt32[123]>
    v2:CBool = PrimitiveCompare<NotEqual> v0 v1
    v3:Bool = PrimitiveBoxBool v2
    Return v3
  }
}
---
LoadVarObjectSizeWithKnownTupleElidesEmitsLoadConst
---
def test(a, b, c):
  d, e, f, _ = (a, b, c, 1)  # the 1 forces an UNPACK_SEQUENCE
  return d
---
fun jittestmodule:test {
  bb 0 {
    v19:Object = LoadArg<0; "a">
    v20:Object = LoadArg<1; "b">
    v21:Object = LoadArg<2; "c">
    v22:Nullptr = LoadConst<Nullptr>
    v26:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v27:MortalTupleExact = MakeTuple<4> v19 v20 v21 v26 {
      FrameState {
        NextInstrOffset 10
        Locals<7> v19 v20 v21 v22 v22 v22 v22
        Stack<4> v19 v20 v21 v26
      }
    }
    UseType<MortalTupleExact> v27
    v28:CInt64[24] = LoadConst<CInt64[24]>
    v29:CPtr = LoadFieldAddress v27 v28
    UseType<MortalTupleExact> v27
    v64:CInt64[4] = LoadConst<CInt64[4]>
    v33:CInt64[4] = LoadConst<CInt64[4]>
    UseType<CInt64[4]> v64
    UseType<CInt64[4]> v33
    v65:CBool[true] = LoadConst<CBool[true]>
    v35:CInt64[3] = LoadConst<CInt64[3]>
    UseType<TupleExact> v27
    UseType<CInt64[3]> v35
    v38:CInt64[2] = LoadConst<CInt64[2]>
    UseType<TupleExact> v27
    UseType<CInt64[2]> v38
    v40:CInt64[1] = LoadConst<CInt64[1]>
    UseType<TupleExact> v27
    UseType<CInt64[1]> v40
    v42:CInt64[0] = LoadConst<CInt64[0]>
    UseType<TupleExact> v27
    UseType<CInt64[0]> v42
    Return v19
  }
}
---
VectorCallWithTooManyArgsStaysTheSame
---
def foo(x, y=4):
  return x

def test():
  return foo(1, 2, 3)
---
fun jittestmodule:test {
  bb 0 {
    v5:OptObject = LoadGlobalCached<0; "foo">
    v6:MortalFunc[function:0xdeadbeef] = GuardIs<0xdeadbeef> v5 {
      Descr 'LOAD_GLOBAL: foo'
    }
    v7:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v8:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v9:ImmortalLongExact[3] = LoadConst<ImmortalLongExact[3]>
    v10:Object = VectorCall<3> v6 v7 v8 v9 {
      FrameState {
        NextInstrOffset 10
      }
    }
    Return v10
  }
}
---
VectorCallWithUnnecessaryDefaultsKeepsArgs
---
def foo(x, y=3):
  return x

def test():
  return foo(1, 2)
---
fun jittestmodule:test {
  bb 0 {
    v4:OptObject = LoadGlobalCached<0; "foo">
    v5:MortalFunc[function:0xdeadbeef] = GuardIs<0xdeadbeef> v4 {
      Descr 'LOAD_GLOBAL: foo'
    }
    v6:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v7:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v8:Object = VectorCall<2> v5 v6 v7 {
      FrameState {
        NextInstrOffset 8
      }
    }
    Return v8
  }
}
---
VectorCallHasDefaultsFilledIn
---
def foo(a, b, c=3, d=4):
  return x

def test():
  return foo(1, 2)
---
fun jittestmodule:test {
  bb 0 {
    v4:OptObject = LoadGlobalCached<0; "foo">
    v5:MortalFunc[function:0xdeadbeef] = GuardIs<0xdeadbeef> v4 {
      Descr 'LOAD_GLOBAL: foo'
    }
    v6:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v7:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v9:ImmortalLongExact[3] = LoadConst<ImmortalLongExact[3]>
    v10:ImmortalLongExact[4] = LoadConst<ImmortalLongExact[4]>
    v11:Tuple = LoadField<func_defaults@56, Tuple, borrowed> v5
    v12:MortalTupleExact[tuple:0xdeadbeef] = GuardIs<0xdeadbeef> v11 {
    }
    v13:Object = VectorCall<4> v5 v6 v7 v9 v10 {
      FrameState {
        NextInstrOffset 8
      }
    }
    Return v13
  }
}
---
LoadMethodFromTypeIsSpecialized
---
class Foo:
  def regular_meth(x, y):
    return x + y
def test():
  return Foo.regular_meth(1, 2)
---
fun jittestmodule:test {
  bb 0 {
    v6:OptObject = LoadGlobalCached<0; "Foo">
    v7:MortalTypeExact[Foo:obj] = GuardIs<0xdeadbeef> v6 {
      Descr 'LOAD_GLOBAL: Foo'
    }
    UseType<Type> v7
    v13:OptType = LoadTypeMethodCacheEntryType<0>
    v14:CBool = PrimitiveCompare<Equal> v13 v7
    CondBranch<1, 2> v14
  }

  bb 1 (preds 0) {
    v15:Object = LoadTypeMethodCacheEntryValue<0> v7
    Branch<3>
  }

  bb 2 (preds 0) {
    v16:Object = FillTypeMethodCache<0, 1> v7 {
      FrameState {
        NextInstrOffset 4
      }
    }
    Branch<3>
  }

  bb 3 (preds 1, 2) {
    v17:Object = Phi<1, 2> v15 v16
    v9:OptObject = GetSecondOutput<OptObject> v17
    v10:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v11:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v12:Object = CallMethod<4> v17 v9 v10 v11 {
      FrameState {
        NextInstrOffset 10
      }
    }
    Return v12
  }
}
---
LoadClassMethodFromTypeIsSpecialized
---
class Foo:
  @classmethod
  def meth(cls, x, y):
    return x + y

def test():
  return Foo.meth(1, 2)
---
fun jittestmodule:test {
  bb 0 {
    v6:OptObject = LoadGlobalCached<0; "Foo">
    v7:MortalTypeExact[Foo:obj] = GuardIs<0xdeadbeef> v6 {
      Descr 'LOAD_GLOBAL: Foo'
    }
    UseType<Type> v7
    v13:OptType = LoadTypeMethodCacheEntryType<0>
    v14:CBool = PrimitiveCompare<Equal> v13 v7
    CondBranch<1, 2> v14
  }

  bb 1 (preds 0) {
    v15:Object = LoadTypeMethodCacheEntryValue<0> v7
    Branch<3>
  }

  bb 2 (preds 0) {
    v16:Object = FillTypeMethodCache<0, 1> v7 {
      FrameState {
        NextInstrOffset 4
      }
    }
    Branch<3>
  }

  bb 3 (preds 1, 2) {
    v17:Object = Phi<1, 2> v15 v16
    v9:OptObject = GetSecondOutput<OptObject> v17
    v10:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v11:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v12:Object = CallMethod<4> v17 v9 v10 v11 {
      FrameState {
        NextInstrOffset 10
      }
    }
    Return v12
  }
}
---
LoadStaticMethodFromTypeIsSpecialized
---
class Foo:
  @staticmethod
  def meth(x, y):
    return x + y

def test():
  return Foo.meth(1, 2)
---
fun jittestmodule:test {
  bb 0 {
    v6:OptObject = LoadGlobalCached<0; "Foo">
    v7:MortalTypeExact[Foo:obj] = GuardIs<0xdeadbeef> v6 {
      Descr 'LOAD_GLOBAL: Foo'
    }
    UseType<Type> v7
    v13:OptType = LoadTypeMethodCacheEntryType<0>
    v14:CBool = PrimitiveCompare<Equal> v13 v7
    CondBranch<1, 2> v14
  }

  bb 1 (preds 0) {
    v15:Object = LoadTypeMethodCacheEntryValue<0> v7
    Branch<3>
  }

  bb 2 (preds 0) {
    v16:Object = FillTypeMethodCache<0, 1> v7 {
      FrameState {
        NextInstrOffset 4
      }
    }
    Branch<3>
  }

  bb 3 (preds 1, 2) {
    v17:Object = Phi<1, 2> v15 v16
    v9:OptObject = GetSecondOutput<OptObject> v17
    v10:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v11:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v12:Object = CallMethod<4> v17 v9 v10 v11 {
      FrameState {
        NextInstrOffset 10
      }
    }
    Return v12
  }
}
---
LoadMethodFromBuiltinTypeIsSpecialized
---
def test():
  return int.__add__(1, 2)
---
fun jittestmodule:test {
  bb 0 {
    v6:OptObject = LoadGlobalCached<0; "int">
    v7:ImmortalTypeExact[int:obj] = GuardIs<0xdeadbeef> v6 {
      Descr 'LOAD_GLOBAL: int'
    }
    UseType<Type> v7
    v13:OptType = LoadTypeMethodCacheEntryType<0>
    v14:CBool = PrimitiveCompare<Equal> v13 v7
    CondBranch<1, 2> v14
  }

  bb 1 (preds 0) {
    v15:Object = LoadTypeMethodCacheEntryValue<0> v7
    Branch<3>
  }

  bb 2 (preds 0) {
    v16:Object = FillTypeMethodCache<0, 1> v7 {
      FrameState {
        NextInstrOffset 4
      }
    }
    Branch<3>
  }

  bb 3 (preds 1, 2) {
    v17:Object = Phi<1, 2> v15 v16
    v9:OptObject = GetSecondOutput<OptObject> v17
    v10:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v11:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v12:Object = CallMethod<4> v17 v9 v10 v11 {
      FrameState {
        NextInstrOffset 10
      }
    }
    Return v12
  }
}
---
LoadMethodFromModuleIsUnspecialized
---
import time

def test():
  return time.time()
---
fun jittestmodule:test {
  bb 0 {
    v4:OptObject = LoadGlobalCached<0; "time">
    v5:MortalObjectUser[module:0xdeadbeef] = GuardIs<0xdeadbeef> v4 {
      Descr 'LOAD_GLOBAL: time'
    }
    v6:Object = LoadMethod<0; "time"> v5 {
      FrameState {
        NextInstrOffset 4
      }
    }
    v7:OptObject = GetSecondOutput<OptObject> v6
    v8:Object = CallMethod<2> v6 v7 {
      FrameState {
        NextInstrOffset 6
      }
    }
    Return v8
  }
}
---
LoadClassMethodFromInstanceIsUnspecialized
---
class A:
  @classmethod
  def hello(cls):
    return 1
def test():
  return A().hello()
---
fun jittestmodule:test {
  bb 0 {
    v5:OptObject = LoadGlobalCached<0; "A">
    v6:MortalTypeExact[A:obj] = GuardIs<0xdeadbeef> v5 {
      Descr 'LOAD_GLOBAL: A'
    }
    v7:Object = VectorCall<0> v6 {
      FrameState {
        NextInstrOffset 4
      }
    }
    v8:Object = LoadMethod<1; "hello"> v7 {
      FrameState {
        NextInstrOffset 6
      }
    }
    v9:OptObject = GetSecondOutput<OptObject> v8
    v10:Object = CallMethod<2> v8 v9 {
      FrameState {
        NextInstrOffset 8
      }
    }
    Return v10
  }
}
---
UnboxOfBoxedPrimitiveUsesOriginalPrimitive
---
# HIR
fun test {
  bb 0 {
    v0 = LoadArg<0; "a", CInt64>
    v1 = PrimitiveBox<CInt64> v0
    v2 = PrimitiveUnbox<CInt64> v1
    Return<CInt64> v2
  }
}
---
fun test {
  bb 0 {
    v0:CInt64 = LoadArg<0, CInt64>
    v1:LongExact = PrimitiveBox<CInt64> v0 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return<CInt64> v0
  }
}
---
UnboxOfBoxedPrimitiveDoesNotSeeThroughPhi
---
# HIR
fun test {
  bb 0 {
    v0 = LoadArg<0; "a", CInt64>
    v1 = LoadArg<1; "b", CInt64>
    v2 = LoadArg<2; "cond", CBool>
    CondBranch<1,2> v2
  }

  bb 1 {
    v3 = PrimitiveBox<CInt64> v0
    Branch<3>
  }

  bb 2 {
    v4 = PrimitiveBox<CInt64> v1
    Branch<3>
  }

  bb 3 {
    v5 = Phi<1, 2> v3 v4
    v6 = PrimitiveUnbox<CInt64> v5
    Return<CInt64> v6
  }
}
---
fun test {
  bb 0 {
    v0:CInt64 = LoadArg<0, CInt64>
    v1:CInt64 = LoadArg<1, CInt64>
    v2:CBool = LoadArg<2, CBool>
    CondBranch<1, 2> v2
  }

  bb 1 (preds 0) {
    v3:LongExact = PrimitiveBox<CInt64> v0 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Branch<3>
  }

  bb 2 (preds 0) {
    v4:LongExact = PrimitiveBox<CInt64> v1 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Branch<3>
  }

  bb 3 (preds 1, 2) {
    v5:LongExact = Phi<1, 2> v3 v4
    v6:CInt64 = PrimitiveUnbox<CInt64> v5
    Return<CInt64> v6
  }
}
---